<!DOCTYPE html><html lang="en" class="no-js"><head><meta charSet="utf-8"/><title>Sidney Liebrand&#x27;s blog - Codi.vim + fullscreen buffer</title><link rel="canonical" href="https://sidneyliebrand.io/blog/codi-vim-fullscreen-buffer"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#a676ff"/><link rel="icon" sizes="48x48" type="image/icon" href="/favicon.ico"/><link rel="icon" sizes="16x16" type="image/png" href="/favicon-16x16.png"/><link rel="icon" sizes="32x32" type="image/png" href="/favicon-32x32.png"/><link rel="apple-touch-icon" sizes="180x180" type="image/png" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" title="The official https://sidneyliebrand.io Atom feed" href="/atom.xml"/><link rel="alternate" type="application/rss+xml" title="The official https://sidneyliebrand.io RSS feed" href="/feed.xml"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="theme-color" content="#ffffff"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="robots" content="index, follow"/><meta name="author" content="Sidney Liebrand"/><meta name="description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;."/><meta property="og:title" content="Codi.vim + fullscreen buffer"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sidneyliebrand.io"/><meta property="og:site_name" content="https://sidneyliebrand.io"/><meta property="og:description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;."/><meta name="dc:creator" content="Sidney Liebrand"/><meta name="dc:title" content="Codi.vim + fullscreen buffer"/><meta name="dc:description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;."/><meta name="twitter:card" content="summary"/><meta name="twitter:creator"/><meta name="next-head-count" content="27"/><script>window.themeBackgrounds={light:"#efefef",dark:"#111"},window.themeNames=Object.keys(themeBackgrounds),function(){var e,a=window.themeBackgrounds||{},c=Object.keys(a),t=document,n=t.querySelector("html"),o=t.createElement("style");try{e=localStorage.getItem("theme")}catch(e){}function r(e,t){if(c.forEach(function(e){n.classList.remove(e)}),e&&(n.classList.add(e),o.innerHTML="html { background-color:"+a[e]+"; }"),t)try{e?localStorage.setItem("theme",e):localStorage.removeItem("theme")}catch(e){}}e=e||"light",n.classList.remove("no-js"),t.head.appendChild(o),window.addEventListener("click",function(e){e=e.target.getAttribute("data-theme");e&&r(e,!0)}),window.addEventListener("storage",function(e){"theme"===e.key&&r(e.newValue)}),window.matchMedia&&(t=window.matchMedia("(prefers-color-scheme: dark)"),!e&&t.matches&&(e="dark"),t.addEventListener("change",function(e){try{localStorage.getItem("theme")||r(e.matches?"dark":"light")}catch(e){}})),r(e)}();</script><link rel="preload" href="/_next/static/media/34a9823ac715e2c2-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/5ddf0f087aa436cc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5ddf0f087aa436cc.css" data-n-g=""/><link rel="preload" href="/_next/static/css/16be28a706dda4bd.css" as="style"/><link rel="stylesheet" href="/_next/static/css/16be28a706dda4bd.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/_next/static/chunks/main-f61746aa183f4a64.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4c4ea7e9525e38e7.js" defer=""></script><script src="/_next/static/chunks/270-41e5c3fe94830822.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-0449096edb900473.js" defer=""></script><script src="/_next/static/7K4G9-e--UwOwapi17Dt3/_buildManifest.js" defer=""></script><script src="/_next/static/7K4G9-e--UwOwapi17Dt3/_ssgManifest.js" defer=""></script></head><style>html.light { --prism-plain-backgroundColor: #f6f8fa;--prism-plain-color: #393A34;--prism-comment-color: #999988;--prism-comment-fontStyle: italic;--prism-prolog-color: #999988;--prism-prolog-fontStyle: italic;--prism-cdata-color: #999988;--prism-cdata-fontStyle: italic;--prism-doctype-color: #999988;--prism-doctype-fontStyle: italic;--prism-punctuation-color: #393A34;--prism-entity-color: #36acaa;--prism-attr-name-color: #00a4db;--prism-boolean-color: #36acaa;--prism-constant-color: #36acaa;--prism-number-color: #36acaa;--prism-atrule-color: #00a4db;--prism-keyword-color: #00009f;--prism-property-color: #36acaa;--prism-tag-color: #00009f;--prism-symbol-color: #36acaa;--prism-deleted-color: #d73a49;--prism-selector-color: #00009f;--prism-string-color: #e3116c;--prism-inserted-color: #36acaa;--prism-regex-color: #36acaa;--prism-attr-value-color: #e3116c;--prism-variable-color: #36acaa;--prism-operator-color: #393A34;--prism-function-color: #d73a49;--prism-url-color: #36acaa;--prism-namespace-opacity: 0.7;--prism-function-variable-color: #6f42c1; }
html.dark { --prism-plain-backgroundColor: hsl(220, 13%, 18%);--prism-plain-color: hsl(220, 14%, 71%);--prism-plain-textShadow: 0 1px rgba(0, 0, 0, 0.3);--prism-comment-color: hsl(220, 10%, 40%);--prism-prolog-color: hsl(220, 10%, 40%);--prism-cdata-color: hsl(220, 10%, 40%);--prism-doctype-color: hsl(220, 14%, 71%);--prism-punctuation-color: hsl(220, 14%, 71%);--prism-entity-color: hsl(220, 14%, 71%);--prism-attr-name-color: hsl(29, 54%, 61%);--prism-class-name-color: hsl(29, 54%, 61%);--prism-maybe-class-name-color: hsl(29, 54%, 61%);--prism-boolean-color: hsl(29, 54%, 61%);--prism-constant-color: hsl(29, 54%, 61%);--prism-number-color: hsl(29, 54%, 61%);--prism-atrule-color: hsl(29, 54%, 61%);--prism-keyword-color: hsl(286, 60%, 67%);--prism-property-color: hsl(355, 65%, 65%);--prism-tag-color: hsl(355, 65%, 65%);--prism-symbol-color: hsl(355, 65%, 65%);--prism-deleted-color: hsl(355, 65%, 65%);--prism-deleted-textDecorationLine: line-through;--prism-important-color: hsl(220, 14%, 71%);--prism-important-fontWeight: bold;--prism-selector-color: hsl(95, 38%, 62%);--prism-string-color: hsl(95, 38%, 62%);--prism-char-color: hsl(95, 38%, 62%);--prism-builtin-color: hsl(95, 38%, 62%);--prism-inserted-color: hsl(95, 38%, 62%);--prism-inserted-textDecorationLine: underline;--prism-regex-color: hsl(95, 38%, 62%);--prism-attr-value-color: hsl(95, 38%, 62%);--prism-variable-color: hsl(207, 82%, 66%);--prism-operator-color: hsl(207, 82%, 66%);--prism-function-color: hsl(207, 82%, 66%);--prism-url-color: hsl(187, 47%, 55%);--prism-italic-fontStyle: italic;--prism-bold-fontWeight: bold; }</style><body><div id="__next"><div class="layout_application__IkddQ __className_68e9d9"><header class="layout_header__lNxPJ"><div class="layout_headerFixed__ej7pM"><div class="layout_headerContent__642Ih"><a class="layout_logo__49Jw1" title="View home page" href="/"><span class="layout_logoTopLeft__UsCFV"></span><span class="layout_logoBottomLeft__W2FUi"></span><span class="layout_logoTopRight__9N83w"></span><span class="layout_logoBottomRight__b_2V_"></span></a><nav class="layout_navigation__hy8pt"><a title="View curriculum vitae" href="/cv">C.V.</a><a class="layout_githubWrapper__pLthy" title="Visit Sidney Liebrand&#x27;s GitHub page" href="https://github.com/SidOfc"><figure class="layout_github__Ge5i1 media_figure__RzsMp media_invertDark__G1aHC"><div class="media_relative__wEFhS" style="padding-bottom:100%"><img loading="lazy" class="media_media__ljErE" src="/media/github.svg" alt="Sidney Liebrand&#x27;s GitHub page"/></div></figure></a><div tabindex="0" title="Toggle dark theme" class="dark-mode-toggle_wrapper__8a7Po"><svg fill="#000000" data-theme="light" class="dark-mode-toggle_toggle__8hfIH" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path></svg><svg fill="#000000" data-theme="dark" class="dark-mode-toggle_toggle__8hfIH" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M9.5,2c-1.82,0-3.53,0.5-5,1.35c2.99,1.73,5,4.95,5,8.65s-2.01,6.92-5,8.65C5.97,21.5,7.68,22,9.5,22c5.52,0,10-4.48,10-10 S15.02,2,9.5,2z"></path></svg></div></nav></div></div></header><main class="layout_content__485Tc"><article class="post_post__4ClWP"><h1 class="heading_container__p7f5U"><a class="heading_link__Pi9LU" href="/blog/codi-vim-fullscreen-buffer">Codi.vim + fullscreen buffer</a></h1><span class="post_postData__2dqv6 text_page-accent-fg__9oKEM">By Sidney Liebrand on<!-- --> <!-- -->Aug 27, 2018<span class="bullet_bullet__hcGtc">â€¢</span>5<!-- --> min read</span><section><figure class="media_figure__RzsMp"><div class="media_relative__wEFhS" style="padding-bottom:58.133971291866025%"><img loading="lazy" class="media_media__ljErE" src="/media/posts/codi-banner.png" alt="A Codi.vim fullscreen buffer"/></div><figcaption class="media_alt__Zj0Le">A Codi.vim fullscreen buffer</figcaption></figure>
<p>Recently I discovered <a href="https://github.com/metakirby5/codi.vim" title="Visit metakirby5/codi.vim on GitHub">codi.vim</a> on <a href="https://vimawesome.com/?q=cat%3Aother" title="Visit vimawesome.com &#x27;Other&#x27; category plugin">vimawesome.com</a>.
It sells itself as an &quot;interactive scratchpad for hackers&quot;.
After playing around with it for 5 minutes I was completely sold.</p>
<p>I pair program on a weekly basis using various different languages.
I used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.
Making a typo in the middle of a <code>do ... end</code> block in Ruby is quite costly:</p>
<figure class="media_figure__RzsMp"><div class="media_relative__wEFhS" style="padding-bottom:24.20135527589545%"><video class="media_media__ljErE" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/pry-multiline-typo.webm" type="video/webm"/><source src="/media/posts/pry-multiline-typo.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__Zj0Le">Multiline expression typo in Pry</figcaption></figure>
<p>Another thing to note here is that code and results are printed sequentially.
This means that any code you write goes off-screen at least twice as fast because the result is printed below it.</p>
<p>In case of errors and stack traces it can become a lot worse as well.
Codi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:</p>
<figure class="media_figure__RzsMp"><div class="media_relative__wEFhS" style="padding-bottom:13.649564375605033%"><video class="media_media__ljErE" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/ruby-demo.webm" type="video/webm"/><source src="/media/posts/ruby-demo.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__Zj0Le">Demo of Ruby in Codi.vim</figcaption></figure>
<p>This feature, and the fact that I can toggle this buffer for <em>multiple programming languages</em> using a single mapping blew my mind but as with anything,
it requires some more battle testing to see if it works in common scenario&#x27;s.</p>
<h2 class="heading_container__p7f5U"><a class="heading_anchor__aTAKr" id="battle-testing"></a><a class="heading_link__Pi9LU" href="#battle-testing">Battle testing</a></h2>
<p>This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:</p>
<figure class="media_figure__RzsMp"><div class="media_relative__wEFhS" style="padding-bottom:48.01548886737657%"><video class="media_media__ljErE" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/split-behavior.webm" type="video/webm"/><source src="/media/posts/split-behavior.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__Zj0Le">Default split behavior</figcaption></figure>
<p>At this point I started experimenting with a small <a href="https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e" title="Visit codi.vim snippet github gist">vimscript snippet</a> in my .vimrc.
Excluding comments and blanks it is 10 LoC.
It wraps the default <code>Codi</code> command in a function which creates an empty buffer in a new tab with the right filetype set before finally running <code>Codi</code> itself.
This creates the fullscreen split that I wanted:</p>
<figure class="media_figure__RzsMp"><div class="media_relative__wEFhS" style="padding-bottom:48.01548886737657%"><video class="media_media__ljErE" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/wrapped-split-behavior.webm" type="video/webm"/><source src="/media/posts/wrapped-split-behavior.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__Zj0Le">Enhanced split behavior</figcaption></figure>
<h2 class="heading_container__p7f5U"><a class="heading_anchor__aTAKr" id="problem-solved-or-maybe-not"></a><a class="heading_link__Pi9LU" href="#problem-solved-or-maybe-not">Problem solved, or maybe not?</a></h2>
<p>All good so far, but upon closing the buffer, the contents of the buffer are deleted.
While automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.</p>
<p>This required a <a href="https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62" title="Visit second codi.vim snippet github gist">second iteration</a> of the original vimscript snippet.
This time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.
After hiding the buffer, its <code>tabpagenr()</code> is stored in a dictionary keyed by the filetype of the buffer.</p>
<p>Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):</p>
<figure class="media_figure__RzsMp"><div class="media_relative__wEFhS" style="padding-bottom:48.01548886737657%"><video class="media_media__ljErE" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/wrapped-split-behavior-2.webm" type="video/webm"/><source src="/media/posts/wrapped-split-behavior-2.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__Zj0Le">Enhanced split behavior version 2</figcaption></figure>
<p>And there we go! Aside from the fact that the buffer now remains, the name is also <code>scratch::ruby</code>.
This is a bit more descriptive than having just <code>[Scratch]</code> in <code>:ls</code> output when multiple codi buffers of a different filetype are active.</p>
<h2 class="heading_container__p7f5U"><a class="heading_anchor__aTAKr" id="let-s-wrap-it-in-an-issue"></a><a class="heading_link__Pi9LU" href="#let-s-wrap-it-in-an-issue">Let&#x27;s wrap it in an issue</a></h2>
<p>It was a fun experience tweaking this plugin to my liking.
I thought this feature would be so awesome that I even proposed it in an <a href="https://github.com/metakirby5/codi.vim/issues/94" title="View metakirby5/codi.vim issue #94">issue</a>.
Unfortunately it didn&#x27;t make it since it was too workflow specific.</p>
<p>As you may have been able to see in the issue though, the code in that snippet is <em>slighty</em> different from the example gist linked in this post.
The main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:</p>
<pre class="prism-code language-vim" style="background-color:var(--prism-plain-backgroundColor);color:var(--prism-plain-color);text-shadow:var(--prism-plain-textShadow)"><div class="token-line" style="color:var(--prism-plain-color);text-shadow:var(--prism-plain-textShadow)"><span class="token comment" style="color:var(--prism-comment-color);font-style:var(--prism-comment-fontStyle)">&quot; since it is fullscreen, I&#x27;d like a 50/50 split</span><span class="token plain"></span></div><div class="token-line" style="color:var(--prism-plain-color);text-shadow:var(--prism-plain-textShadow)"><span class="token plain"></span><span class="token keyword" style="color:var(--prism-keyword-color)">let</span><span class="token plain"> g</span><span class="token punctuation" style="color:var(--prism-punctuation-color)">:</span><span class="token plain">codi#width </span><span class="token operator" style="color:var(--prism-operator-color)">=</span><span class="token plain"> </span><span class="token function" style="color:var(--prism-function-color)">winwidth</span><span class="token punctuation" style="color:var(--prism-punctuation-color)">(</span><span class="token function" style="color:var(--prism-function-color)">winnr</span><span class="token punctuation" style="color:var(--prism-punctuation-color)">(</span><span class="token punctuation" style="color:var(--prism-punctuation-color)">)</span><span class="token punctuation" style="color:var(--prism-punctuation-color)">)</span><span class="token plain"> </span><span class="token operator" style="color:var(--prism-operator-color)">/</span><span class="token plain"> </span><span class="token number" style="color:var(--prism-number-color)">2</span></div></pre>
<p>The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.
So I went ahead and <a href="https://github.com/metakirby5/codi.vim/pull/95" title="View metakirby5/codi.vim pull request #95">wrote a PR</a> for that instead, this is why you see
<code>let g:codi#width = 50.0</code> in the gists :)</p>
<h2 class="heading_container__p7f5U"><a class="heading_anchor__aTAKr" id="conclusion"></a><a class="heading_link__Pi9LU" href="#conclusion">Conclusion</a></h2>
<p>All in all it was a great experience discovering this plugin.
It is like one of those rare cases with a song where after a few seconds <strong>you just know</strong> <em>&quot;this song is awesome&quot;</em>.
I believe I&#x27;ll be using it for a long time to come for quickly testing and showing some code.</p>
<p>This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.
Something which I wanted to do for a long time but couldn&#x27;t really find the right project to contribute to.
I want to thank <a href="https://medium.com/@metakirby5" title="View @metakirby5 on Medium">Ethan Chan</a> for his awesome plugin and for being a kind and friendly maintainer!</p>
<p>That&#x27;s it! If you want a fullscreen workflow with codi.vim, you have it.
If you want to persist the code in the buffer, you have it.
If you have a great idea, comment on this post!</p>
<p>Until next time.</p>
<p>ðŸ‘‹</p></section><a href="/"><button tabindex="0" class="button_button__dZRSb">Back</button></a></article></main><footer class="layout_footer__SUiec"><strong>Â©</strong> sidneyliebrand.io<!-- --> <!-- -->2024<span class="bullet_bullet__hcGtc bullet_wide__LCzNj">â€¢</span><a title="View RSS feed" href="/feed.xml">RSS</a><span class="bullet_bullet__hcGtc bullet_wide__LCzNj">â€¢</span><a title="View Atom feed" href="/atom.xml">Atom</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the \u003ccode\u003eCodi\u003c/code\u003e command and improving the buffer name(s) as seen in \u003ccode\u003e:ls\u003c/code\u003e.","published":"2018-08-27T07:55:24Z","readTimeInMinutes":5,"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    em: \"em\",\n    h2: \"h2\",\n    pre: \"pre\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components), {Media} = _components;\n  if (!Media) _missingMdxReference(\"Media\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(Media, {\n      src: \"/media/posts/codi-banner.png\",\n      alt: \"A Codi.vim fullscreen buffer\",\n      width: \"1672\",\n      height: \"972\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Recently I discovered \", _jsx(_components.a, {\n        href: \"https://github.com/metakirby5/codi.vim\",\n        title: \"Visit metakirby5/codi.vim on GitHub\",\n        children: \"codi.vim\"\n      }), \" on \", _jsx(_components.a, {\n        href: \"https://vimawesome.com/?q=cat%3Aother\",\n        title: \"Visit vimawesome.com 'Other' category plugin\",\n        children: \"vimawesome.com\"\n      }), \".\\nIt sells itself as an \\\"interactive scratchpad for hackers\\\".\\nAfter playing around with it for 5 minutes I was completely sold.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I pair program on a weekly basis using various different languages.\\nI used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.\\nMaking a typo in the middle of a \", _jsx(_components.code, {\n        children: \"do ... end\"\n      }), \" block in Ruby is quite costly:\"]\n    }), \"\\n\", _jsx(Media, {\n      src: \"/media/posts/pry-multiline-typo\",\n      alt: \"Multiline expression typo in Pry\",\n      width: \"1033\",\n      height: \"250\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another thing to note here is that code and results are printed sequentially.\\nThis means that any code you write goes off-screen at least twice as fast because the result is printed below it.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In case of errors and stack traces it can become a lot worse as well.\\nCodi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:\"\n    }), \"\\n\", _jsx(Media, {\n      src: \"/media/posts/ruby-demo\",\n      alt: \"Demo of Ruby in Codi.vim\",\n      width: \"1033\",\n      height: \"141\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This feature, and the fact that I can toggle this buffer for \", _jsx(_components.em, {\n        children: \"multiple programming languages\"\n      }), \" using a single mapping blew my mind but as with anything,\\nit requires some more battle testing to see if it works in common scenario's.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Battle testing\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:\"\n    }), \"\\n\", _jsx(Media, {\n      src: \"/media/posts/split-behavior\",\n      alt: \"Default split behavior\",\n      width: \"1033\",\n      height: \"496\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"At this point I started experimenting with a small \", _jsx(_components.a, {\n        href: \"https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e\",\n        title: \"Visit codi.vim snippet github gist\",\n        children: \"vimscript snippet\"\n      }), \" in my .vimrc.\\nExcluding comments and blanks it is 10 LoC.\\nIt wraps the default \", _jsx(_components.code, {\n        children: \"Codi\"\n      }), \" command in a function which creates an empty buffer in a new tab with the right filetype set before finally running \", _jsx(_components.code, {\n        children: \"Codi\"\n      }), \" itself.\\nThis creates the fullscreen split that I wanted:\"]\n    }), \"\\n\", _jsx(Media, {\n      src: \"/media/posts/wrapped-split-behavior\",\n      alt: \"Enhanced split behavior\",\n      width: \"1033\",\n      height: \"496\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Problem solved, or maybe not?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"All good so far, but upon closing the buffer, the contents of the buffer are deleted.\\nWhile automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This required a \", _jsx(_components.a, {\n        href: \"https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62\",\n        title: \"Visit second codi.vim snippet github gist\",\n        children: \"second iteration\"\n      }), \" of the original vimscript snippet.\\nThis time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.\\nAfter hiding the buffer, its \", _jsx(_components.code, {\n        children: \"tabpagenr()\"\n      }), \" is stored in a dictionary keyed by the filetype of the buffer.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):\"\n    }), \"\\n\", _jsx(Media, {\n      src: \"/media/posts/wrapped-split-behavior-2\",\n      alt: \"Enhanced split behavior version 2\",\n      width: \"1033\",\n      height: \"496\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"And there we go! Aside from the fact that the buffer now remains, the name is also \", _jsx(_components.code, {\n        children: \"scratch::ruby\"\n      }), \".\\nThis is a bit more descriptive than having just \", _jsx(_components.code, {\n        children: \"[Scratch]\"\n      }), \" in \", _jsx(_components.code, {\n        children: \":ls\"\n      }), \" output when multiple codi buffers of a different filetype are active.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Let's wrap it in an issue\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It was a fun experience tweaking this plugin to my liking.\\nI thought this feature would be so awesome that I even proposed it in an \", _jsx(_components.a, {\n        href: \"https://github.com/metakirby5/codi.vim/issues/94\",\n        title: \"View metakirby5/codi.vim issue #94\",\n        children: \"issue\"\n      }), \".\\nUnfortunately it didn't make it since it was too workflow specific.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As you may have been able to see in the issue though, the code in that snippet is \", _jsx(_components.em, {\n        children: \"slighty\"\n      }), \" different from the example gist linked in this post.\\nThe main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-vim\",\n        children: \"\\\" since it is fullscreen, I'd like a 50/50 split\\nlet g:codi#width = winwidth(winnr()) / 2\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.\\nSo I went ahead and \", _jsx(_components.a, {\n        href: \"https://github.com/metakirby5/codi.vim/pull/95\",\n        title: \"View metakirby5/codi.vim pull request #95\",\n        children: \"wrote a PR\"\n      }), \" for that instead, this is why you see\\n\", _jsx(_components.code, {\n        children: \"let g:codi#width = 50.0\"\n      }), \" in the gists :)\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conclusion\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All in all it was a great experience discovering this plugin.\\nIt is like one of those rare cases with a song where after a few seconds \", _jsx(_components.strong, {\n        children: \"you just know\"\n      }), \" \", _jsx(_components.em, {\n        children: \"\\\"this song is awesome\\\"\"\n      }), \".\\nI believe I'll be using it for a long time to come for quickly testing and showing some code.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.\\nSomething which I wanted to do for a long time but couldn't really find the right project to contribute to.\\nI want to thank \", _jsx(_components.a, {\n        href: \"https://medium.com/@metakirby5\",\n        title: \"View @metakirby5 on Medium\",\n        children: \"Ethan Chan\"\n      }), \" for his awesome plugin and for being a kind and friendly maintainer!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That's it! If you want a fullscreen workflow with codi.vim, you have it.\\nIf you want to persist the code in the buffer, you have it.\\nIf you have a great idea, comment on this post!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Until next time.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ðŸ‘‹\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the \u003ccode\u003eCodi\u003c/code\u003e command and improving the buffer name(s) as seen in \u003ccode\u003e:ls\u003c/code\u003e.","published":"2018-08-27T07:55:24Z"}},"slug":"codi-vim-fullscreen-buffer"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"codi-vim-fullscreen-buffer"},"buildId":"7K4G9-e--UwOwapi17Dt3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>