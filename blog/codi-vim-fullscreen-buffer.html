<!DOCTYPE html><html lang="en" class="no-js"><head><script>window.themeBackgrounds={light:"#fff",dark:"#111"},window.themeNames=Object.keys(themeBackgrounds),function(){var t,a=window.themeBackgrounds||{},c=Object.keys(a),e=document,n=e.querySelector("html"),o=e.createElement("style");try{t=localStorage.getItem("theme")}catch(e){t="light"}function r(e,t){if(c.forEach(function(e){n.classList.remove(e)}),e&&(n.classList.add(e),o.innerHTML="html { background-color:"+a[e]+"; }"),t)try{e?localStorage.setItem("theme",e):localStorage.removeItem("theme")}catch(e){}}n.classList.remove("no-js"),e.head.appendChild(o),window.addEventListener("click",function(e){e=e.target.getAttribute("data-theme");e&&r(e,!0)}),window.addEventListener("storage",function(e){"theme"===e.key&&r(e.newValue)}),window.matchMedia&&(e=window.matchMedia("(prefers-color-scheme: dark)"),!t&&e.matches&&(t="dark"),e.addEventListener("change",function(e){try{localStorage.getItem("theme")||r(e.matches?"dark":"light")}catch(e){}})),r(t)}();</script><meta charSet="utf-8"/><title>Sidney Liebrand&#x27;s blog - Codi.vim + fullscreen buffer</title><link rel="canonical" href="https://sidneyliebrand.io/blog/codi-vim-fullscreen-buffer"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#a676ff"/><link rel="icon" sizes="48x48" type="image/icon" href="/favicon.ico"/><link rel="icon" sizes="16x16" type="image/png" href="/favicon-16x16.png"/><link rel="icon" sizes="32x32" type="image/png" href="/favicon-32x32.png"/><link rel="apple-touch-icon" sizes="180x180" type="image/png" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" title="The official https://sidneyliebrand.io Atom feed" href="/atom.xml"/><link rel="alternate" type="application/rss+xml" title="The official https://sidneyliebrand.io RSS feed" href="/feed.xml"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="theme-color" content="#ffffff"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="robots" content="index, follow"/><meta name="author" content="Sidney Liebrand"/><meta name="description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;."/><meta property="og:title" content="Codi.vim + fullscreen buffer"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sidneyliebrand.io"/><meta property="og:site_name" content="https://sidneyliebrand.io"/><meta property="og:description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;."/><meta name="dc:creator" content="Sidney Liebrand"/><meta name="dc:title" content="Codi.vim + fullscreen buffer"/><meta name="dc:description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;."/><meta name="twitter:card" content="summary"/><meta name="twitter:creator" content="@scbydoooo"/><meta name="next-head-count" content="27"/><link rel="preload" href="/_next/static/css/36fcc6313b5c565735a8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/36fcc6313b5c565735a8.css" data-n-g=""/><link rel="preload" href="/_next/static/css/d93aeec1bf2a5cb0c087.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d93aeec1bf2a5cb0c087.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-715970c8028b8d8e1f64.js" defer=""></script><script src="/_next/static/chunks/framework-92300432a1172ef1338b.js" defer=""></script><script src="/_next/static/chunks/main-9fa3b3cc6b02e2e4d87e.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d8e395932e3b8fbc80f4.js" defer=""></script><script src="/_next/static/chunks/30-430388317a322e8a2777.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-cd61ce4cafd638be725c.js" defer=""></script><script src="/_next/static/q8sNabOIFNc1vcdv48Srv/_buildManifest.js" defer=""></script><script src="/_next/static/q8sNabOIFNc1vcdv48Srv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_application__6A4un"><header class="layout_header__3bVjw"><div class="layout_headerFixed__3v8Yi"><div class="layout_headerContent__18ocK"><a class="layout_logo__319hZ" title="View home page" href="/"><span class="layout_logoTopLeft__2TXmp"></span><span class="layout_logoBottomLeft__1VwSz"></span><span class="layout_logoTopRight__36KVG"></span><span class="layout_logoBottomRight__34Roq"></span></a><nav class="layout_navigation__19PAD"><a title="View curriculum vitae" href="/cv">C.V.</a><a title="Visit Sidney Liebrand&#x27;s GitHub page" href="https://github.com/SidOfc"><figure class="layout_github__23ZLB media_figure__1BF98 media_invertDark__1FMJX"><div class="media_relative__3Dzxp" style="padding-bottom:100%"><img loading="lazy" class="media_media__1ZpPG" src="/media/github.svg" alt="Sidney Liebrand&#x27;s GitHub page"/></div></figure></a><div tabindex="0" title="Toggle dark theme" class="dark-mode-toggle_wrapper__bHDaz"><svg fill="#000000" data-theme="light" class="dark-mode-toggle_toggle__2rc2d" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path></svg><svg fill="#000000" data-theme="dark" class="dark-mode-toggle_toggle__2rc2d" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M9.5,2c-1.82,0-3.53,0.5-5,1.35c2.99,1.73,5,4.95,5,8.65s-2.01,6.92-5,8.65C5.97,21.5,7.68,22,9.5,22c5.52,0,10-4.48,10-10 S15.02,2,9.5,2z"></path></svg></div></nav></div></div></header><main class="layout_content__2V5t2"><article class="post_post__2uzyE"><h1 class="heading_container__2UElk"><a class="heading_link__1aoFY" href="/blog/codi-vim-fullscreen-buffer">Codi.vim + fullscreen buffer</a></h1><span class="post_postData__yktVb text_page-accent-fg__3pARq">By Sidney Liebrand on<!-- --> <!-- -->Aug 27, 2018<span class="bullet_bullet__2pnOU">â€¢</span>5<!-- --> min read</span><section><figure class="wide media_figure__1BF98"><div class="media_relative__3Dzxp" style="padding-bottom:58.133971291866025%"><img loading="lazy" class="media_media__1ZpPG" src="/media/posts/codi-banner.png" alt="A Codi.vim fullscreen buffer"/></div><figcaption class="media_alt__xSx7S">A Codi.vim fullscreen buffer</figcaption></figure><p>Recently I discovered <a href="https://github.com/metakirby5/codi.vim" title="Visit metakirby5/codi.vim on GitHub">codi.vim</a> on <a href="https://vimawesome.com/?q=cat%3Aother" title="Visit vimawesome.com &#x27;Other&#x27; category plugin">vimawesome.com</a>.
It sells itself as an &quot;interactive scratchpad for hackers&quot;.
After playing around with it for 5 minutes I was completely sold.</p><p>I pair program on a weekly basis using various different languages.
I used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.
Making a typo in the middle of a <code>do ... end</code> block in Ruby is quite costly:</p><figure class="media_figure__1BF98"><div class="media_relative__3Dzxp" style="padding-bottom:24.20135527589545%"><video class="media_media__1ZpPG" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/pry-multiline-typo.webm" type="video/webm"/><source src="/media/posts/pry-multiline-typo.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__xSx7S">Multiline expression typo in Pry</figcaption></figure><p>Another thing to note here is that code and results are printed sequentially.
This means that any code you write goes off-screen at least twice as fast because the result is printed below it.</p><p>In case of errors and stack traces it can become a lot worse as well.
Codi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:</p><figure class="media_figure__1BF98"><div class="media_relative__3Dzxp" style="padding-bottom:13.649564375605033%"><video class="media_media__1ZpPG" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/ruby-demo.webm" type="video/webm"/><source src="/media/posts/ruby-demo.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__xSx7S">Demo of Ruby in Codi.vim</figcaption></figure><p>This feature, and the fact that I can toggle this buffer for <em>multiple programming languages</em> using a single mapping blew my mind but as with anything,
it requires some more battle testing to see if it works in common scenario&#x27;s.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="battle-testing"></a><a class="heading_link__1aoFY" href="#battle-testing">Battle testing</a></h2><p>This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:</p><figure class="media_figure__1BF98"><div class="media_relative__3Dzxp" style="padding-bottom:48.01548886737657%"><video class="media_media__1ZpPG" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/split-behavior.webm" type="video/webm"/><source src="/media/posts/split-behavior.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__xSx7S">Default split behavior</figcaption></figure><p>At this point I started experimenting with a small <a href="https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e" title="Visit codi.vim snippet github gist">vimscript snippet</a> in my .vimrc.
Excluding comments and blanks it is 10 LoC.
It wraps the default <code>Codi</code> command in a function which creates an empty buffer in a new tab with the right filetype set before finally running <code>Codi</code> itself.
This creates the fullscreen split that I wanted:</p><figure class="media_figure__1BF98"><div class="media_relative__3Dzxp" style="padding-bottom:48.01548886737657%"><video class="media_media__1ZpPG" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/wrapped-split-behavior.webm" type="video/webm"/><source src="/media/posts/wrapped-split-behavior.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__xSx7S">Enhanced split behavior</figcaption></figure><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="problem-solved-or-maybe-not"></a><a class="heading_link__1aoFY" href="#problem-solved-or-maybe-not">Problem solved, or maybe not?</a></h2><p>All good so far, but upon closing the buffer, the contents of the buffer are deleted.
While automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.</p><p>This required a <a href="https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62" title="Visit second codi.vim snippet github gist">second iteration</a> of the original vimscript snippet.
This time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.
After hiding the buffer, its <code>tabpagenr()</code> is stored in a dictionary keyed by the filetype of the buffer.</p><p>Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):</p><figure class="media_figure__1BF98"><div class="media_relative__3Dzxp" style="padding-bottom:48.01548886737657%"><video class="media_media__1ZpPG" autoplay="" loop="" muted="" playsinline=""><source src="/media/posts/wrapped-split-behavior-2.webm" type="video/webm"/><source src="/media/posts/wrapped-split-behavior-2.mp4" type="video/mp4"/></video></div><figcaption class="media_alt__xSx7S">Enhanced split behavior version 2</figcaption></figure><p>And there we go! Aside from the fact that the buffer now remains, the name is also <code>scratch::ruby</code>.
This is a bit more descriptive than having just <code>[Scratch]</code> in <code>:ls</code> output when multiple codi buffers of a different filetype are active.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="let-s-wrap-it-in-an-issue"></a><a class="heading_link__1aoFY" href="#let-s-wrap-it-in-an-issue">Let&#x27;s wrap it in an issue</a></h2><p>It was a fun experience tweaking this plugin to my liking.
I thought this feature would be so awesome that I even proposed it in an <a href="https://github.com/metakirby5/codi.vim/issues/94" title="View metakirby5/codi.vim issue #94">issue</a>.
Unfortunately it didn&#x27;t make it since it was too workflow specific.</p><p>As you may have been able to see in the issue though, the code in that snippet is <em>slighty</em> different from the example gist linked in this post.
The main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:</p><pre class="prism-code language-viml" style="background-color:#2a2734;color:#9a86fd"><div class="token-line" style="color:#9a86fd"><span class="token comment" style="color:#9390a1">&quot; since it is fullscreen, I&#x27;d like a 50/50 split</span><span class="token plain"></span></div><div class="token-line" style="color:#9a86fd"><span class="token plain"></span><span class="token keyword" style="color:#ffcc99">let</span><span class="token plain"> g</span><span class="token punctuation" style="color:#6c6783">:</span><span class="token plain">codi</span><span class="token punctuation" style="color:#6c6783">#</span><span class="token plain">width </span><span class="token operator" style="color:#e09142">=</span><span class="token plain"> </span><span class="token function" style="color:#fa60c3">winwidth</span><span class="token punctuation" style="color:#6c6783">(</span><span class="token function" style="color:#fa60c3">winnr</span><span class="token punctuation" style="color:#6c6783">(</span><span class="token punctuation" style="color:#6c6783">)</span><span class="token punctuation" style="color:#6c6783">)</span><span class="token plain"> </span><span class="token operator" style="color:#e09142">/</span><span class="token plain"> </span><span class="token number" style="color:#e09142">2</span></div></pre><p>The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.
So I went ahead and <a href="https://github.com/metakirby5/codi.vim/pull/95" title="View metakirby5/codi.vim pull request #95">wrote a PR</a> for that instead, this is why you see
<code>let g:codi#width = 50.0</code> in the gists :)</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="conclusion"></a><a class="heading_link__1aoFY" href="#conclusion">Conclusion</a></h2><p>All in all it was a great experience discovering this plugin.
It is like one of those rare cases with a song where after a few seconds <strong>you just know</strong> <em>&quot;this song is awesome&quot;</em>.
I believe I&#x27;ll be using it for a long time to come for quickly testing and showing some code.</p><p>This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.
Something which I wanted to do for a long time but couldn&#x27;t really find the right project to contribute to.
I want to thank <a href="https://medium.com/@metakirby5" title="View @metakirby5 on Medium">Ethan Chan</a> for his awesome plugin and for being a kind and friendly maintainer!</p><p>That&#x27;s it! If you want a fullscreen workflow with codi.vim, you have it.
If you want to persist the code in the buffer, you have it.
If you have a great idea, comment on this post!</p><p>Until next time.</p><p>ðŸ‘‹</p></section><a tabindex="0" class="button_button__LVJFE" href="/">Back</a></article></main><footer class="layout_footer__2cV3b"><strong>Â©</strong> sidneyliebrand.io<!-- --> <!-- -->2021<span class="bullet_bullet__2pnOU bullet_wide__265WB">â€¢</span><a title="View RSS feed" href="/feed.xml">RSS</a><span class="bullet_bullet__2pnOU bullet_wide__265WB">â€¢</span><a title="View Atom feed" href="/atom.xml">Atom</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the \u003ccode\u003eCodi\u003c/code\u003e command and improving the buffer name(s) as seen in \u003ccode\u003e:ls\u003c/code\u003e.","published":"2018-08-27T07:55:24Z","readTimeInMinutes":5,"source":{"compiledSource":"var l=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var h=(e,t,i)=\u003et in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,n=(e,t)=\u003e{for(var i in t||(t={}))s.call(t,i)\u0026\u0026h(e,i,t[i]);if(o)for(var i of o(t))r.call(t,i)\u0026\u0026h(e,i,t[i]);return e},p=(e,t)=\u003ec(e,m(t));var d=(e,t)=\u003e{var i={};for(var a in e)s.call(e,a)\u0026\u0026t.indexOf(a)\u003c0\u0026\u0026(i[a]=e[a]);if(e!=null\u0026\u0026o)for(var a of o(e))t.indexOf(a)\u003c0\u0026\u0026r.call(e,a)\u0026\u0026(i[a]=e[a]);return i};const makeShortcode=e=\u003efunction(i){return console.warn(\"Component \"+e+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",n({},i))},Media=makeShortcode(\"Media\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var a=i,{components:e}=a,t=d(a,[\"components\"]);return mdx(MDXLayout,p(n(n({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(Media,{src:\"/media/posts/codi-banner.png\",alt:\"A Codi.vim fullscreen buffer\",width:\"1672\",height:\"972\",className:\"wide\",mdxType:\"Media\"}),mdx(\"p\",null,\"Recently I discovered \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://github.com/metakirby5/codi.vim\",title:\"Visit metakirby5/codi.vim on GitHub\"}),\"codi.vim\"),\" on \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://vimawesome.com/?q=cat%3Aother\",title:\"Visit vimawesome.com 'Other' category plugin\"}),\"vimawesome.com\"),`.\nIt sells itself as an \"interactive scratchpad for hackers\".\nAfter playing around with it for 5 minutes I was completely sold.`),mdx(\"p\",null,`I pair program on a weekly basis using various different languages.\nI used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.\nMaking a typo in the middle of a `,mdx(\"inlineCode\",{parentName:\"p\"},\"do ... end\"),\" block in Ruby is quite costly:\"),mdx(Media,{src:\"/media/posts/pry-multiline-typo\",alt:\"Multiline expression typo in Pry\",width:\"1033\",height:\"250\",mdxType:\"Media\"}),mdx(\"p\",null,`Another thing to note here is that code and results are printed sequentially.\nThis means that any code you write goes off-screen at least twice as fast because the result is printed below it.`),mdx(\"p\",null,`In case of errors and stack traces it can become a lot worse as well.\nCodi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:`),mdx(Media,{src:\"/media/posts/ruby-demo\",alt:\"Demo of Ruby in Codi.vim\",width:\"1033\",height:\"141\",mdxType:\"Media\"}),mdx(\"p\",null,\"This feature, and the fact that I can toggle this buffer for \",mdx(\"em\",{parentName:\"p\"},\"multiple programming languages\"),` using a single mapping blew my mind but as with anything,\nit requires some more battle testing to see if it works in common scenario's.`),mdx(\"h2\",null,\"Battle testing\"),mdx(\"p\",null,\"This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:\"),mdx(Media,{src:\"/media/posts/split-behavior\",alt:\"Default split behavior\",width:\"1033\",height:\"496\",mdxType:\"Media\"}),mdx(\"p\",null,\"At this point I started experimenting with a small \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e\",title:\"Visit codi.vim snippet github gist\"}),\"vimscript snippet\"),` in my .vimrc.\nExcluding comments and blanks it is 10 LoC.\nIt wraps the default `,mdx(\"inlineCode\",{parentName:\"p\"},\"Codi\"),\" command in a function which creates an empty buffer in a new tab with the right filetype set before finally running \",mdx(\"inlineCode\",{parentName:\"p\"},\"Codi\"),` itself.\nThis creates the fullscreen split that I wanted:`),mdx(Media,{src:\"/media/posts/wrapped-split-behavior\",alt:\"Enhanced split behavior\",width:\"1033\",height:\"496\",mdxType:\"Media\"}),mdx(\"h2\",null,\"Problem solved, or maybe not?\"),mdx(\"p\",null,`All good so far, but upon closing the buffer, the contents of the buffer are deleted.\nWhile automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.`),mdx(\"p\",null,\"This required a \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62\",title:\"Visit second codi.vim snippet github gist\"}),\"second iteration\"),` of the original vimscript snippet.\nThis time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.\nAfter hiding the buffer, its `,mdx(\"inlineCode\",{parentName:\"p\"},\"tabpagenr()\"),\" is stored in a dictionary keyed by the filetype of the buffer.\"),mdx(\"p\",null,\"Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):\"),mdx(Media,{src:\"/media/posts/wrapped-split-behavior-2\",alt:\"Enhanced split behavior version 2\",width:\"1033\",height:\"496\",mdxType:\"Media\"}),mdx(\"p\",null,\"And there we go! Aside from the fact that the buffer now remains, the name is also \",mdx(\"inlineCode\",{parentName:\"p\"},\"scratch::ruby\"),`.\nThis is a bit more descriptive than having just `,mdx(\"inlineCode\",{parentName:\"p\"},\"[Scratch]\"),\" in \",mdx(\"inlineCode\",{parentName:\"p\"},\":ls\"),\" output when multiple codi buffers of a different filetype are active.\"),mdx(\"h2\",null,\"Let's wrap it in an issue\"),mdx(\"p\",null,`It was a fun experience tweaking this plugin to my liking.\nI thought this feature would be so awesome that I even proposed it in an `,mdx(\"a\",n({parentName:\"p\"},{href:\"https://github.com/metakirby5/codi.vim/issues/94\",title:\"View metakirby5/codi.vim issue #94\"}),\"issue\"),`.\nUnfortunately it didn't make it since it was too workflow specific.`),mdx(\"p\",null,\"As you may have been able to see in the issue though, the code in that snippet is \",mdx(\"em\",{parentName:\"p\"},\"slighty\"),` different from the example gist linked in this post.\nThe main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:`),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-viml\"}),`\" since it is fullscreen, I'd like a 50/50 split\nlet g:codi#width = winwidth(winnr()) / 2\n`)),mdx(\"p\",null,`The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.\nSo I went ahead and `,mdx(\"a\",n({parentName:\"p\"},{href:\"https://github.com/metakirby5/codi.vim/pull/95\",title:\"View metakirby5/codi.vim pull request #95\"}),\"wrote a PR\"),` for that instead, this is why you see\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"let g:codi#width = 50.0\"),\" in the gists :)\"),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,`All in all it was a great experience discovering this plugin.\nIt is like one of those rare cases with a song where after a few seconds `,mdx(\"strong\",{parentName:\"p\"},\"you just know\"),\" \",mdx(\"em\",{parentName:\"p\"},'\"this song is awesome\"'),`.\nI believe I'll be using it for a long time to come for quickly testing and showing some code.`),mdx(\"p\",null,`This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.\nSomething which I wanted to do for a long time but couldn't really find the right project to contribute to.\nI want to thank `,mdx(\"a\",n({parentName:\"p\"},{href:\"https://medium.com/@metakirby5\",title:\"View @metakirby5 on Medium\"}),\"Ethan Chan\"),\" for his awesome plugin and for being a kind and friendly maintainer!\"),mdx(\"p\",null,`That's it! If you want a fullscreen workflow with codi.vim, you have it.\nIf you want to persist the code in the buffer, you have it.\nIf you have a great idea, comment on this post!`),mdx(\"p\",null,\"Until next time.\"),mdx(\"p\",null,\"\\u{1F44B}\"))}MDXContent.isMDXComponent=!0;\n","scope":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the \u003ccode\u003eCodi\u003c/code\u003e command and improving the buffer name(s) as seen in \u003ccode\u003e:ls\u003c/code\u003e.","published":"2018-08-27T07:55:24Z"}},"slug":"codi-vim-fullscreen-buffer"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"codi-vim-fullscreen-buffer"},"buildId":"q8sNabOIFNc1vcdv48Srv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>