<!DOCTYPE html><html lang="en" class="no-js"><head><script>var e=document,a=e.querySelector("html"),c=e.createElement("style"),r={light:"#fff",dark:"#111"},o=Object.keys(r);function t(e,t){if(e&&(o.forEach(function(e){a.classList.remove(e)}),a.classList.add(e),c.innerHTML="html { background-color:"+r[e]+"; }",t))try{localStorage.setItem("theme",e)}catch(e){}}a.classList.remove("no-js"),e.head.appendChild(c),window.addEventListener("click",function(e){t(e.target.getAttribute("data-theme"),!0)},{passive:!0});try{var n,i=localStorage.getItem("theme");window.matchMedia&&(n=window.matchMedia("(prefers-color-scheme: dark)"),!i&&n.matches&&(i="dark"),n.addEventListener("change",function(e){localStorage.getItem("theme")||t(e.matches?"dark":"light")})),t(i)}catch(e){}</script><meta charSet="utf-8" /><title>Codi.vim + fullscreen buffer</title><link rel="cannonical" href="https://sidneyliebrand.io/blog/codi-vim-fullscreen-buffer" /><link rel="manifest" href="/site.webmanifest" /><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#a676ff" /><link rel="icon" sizes="48x48" type="image/icon" href="/favicon.ico" /><link rel="icon" sizes="16x16" type="image/png" href="/favicon-16x16.png" /><link rel="icon" sizes="32x32" type="image/png" href="/favicon-32x32.png" /><link rel="apple-touch-icon" sizes="180x180" type="image/png" href="/apple-touch-icon.png" /><link rel="alternate" type="application/atom+xml" title="The official https://sidneyliebrand.io Atom feed" href="/atom.xml" /><link rel="alternate" type="application/rss+xml" title="The official https://sidneyliebrand.io RSS feed" href="/feed.xml" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="theme-color" content="#ffffff" /><meta name="msapplication-TileColor" content="#ffc40d" /><meta name="robots" content="index, follow" /><meta name="author" content="Sidney Liebrand" /><meta name="description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;." /><meta property="og:title" content="Codi.vim + fullscreen buffer" /><meta property="og:type" content="website" /><meta property="og:url" content="https://sidneyliebrand.io" /><meta property="og:site_name" content="https://sidneyliebrand.io" /><meta property="og:description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;." /><meta name="dc:creator" content="Sidney Liebrand" /><meta name="dc:title" content="Codi.vim + fullscreen buffer" /><meta name="dc:description" content="Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the &lt;code&gt;Codi&lt;/code&gt; command and improving the buffer name(s) as seen in &lt;code&gt;:ls&lt;/code&gt;." /><meta name="twitter:card" content="summary" /><meta name="twitter:creator" content="@scbydoooo" /><meta name="next-head-count" content="27" /><link rel="preload" href="/_next/static/css/1ef9933dc18cef4bb06c.css" as="style" /><link rel="stylesheet" href="/_next/static/css/1ef9933dc18cef4bb06c.css" data-n-g /><link rel="preload" href="/_next/static/css/7278554459c29aab09b9.css" as="style" /><link rel="stylesheet" href="/_next/static/css/7278554459c29aab09b9.css" data-n-p /><noscript data-n-css></noscript></head><body><div id="__next"><div class="layout_application__6A4un"><header class="layout_header__3bVjw"><div class="progress_progress__16ejW"><div style="width: 0%; opacity: 0;" class="progress_indicator__sQ7in"></div></div><div class="layout_headerFixed__3v8Yi"><div class="layout_headerContent__18ocK"><a title="View home page" class="layout_logo__319hZ" href="/"><span class="layout_logoTopLeft__2TXmp"></span><span class="layout_logoBottomLeft__1VwSz"></span><span class="layout_logoTopRight__36KVG"></span><span class="layout_logoBottomRight__34Roq"></span></a><nav class="layout_navigation__19PAD"><a title="View curriculum vitae" href="/cv">C.V.</a><a title="Visit Sidney Liebrand's GitHub page" href="https://github.com/SidOfc"><figure class="layout_github__23ZLB media_figure__1BF98 media_invertDark__1FMJX"><div style="padding-bottom: 100%;" class="media_relative__3Dzxp"><img loading="lazy" src="/media/github.svg" alt="Sidney Liebrand's GitHub page" class="media_media__1ZpPG" /></div></figure></a><div tabIndex="0" title="Toggle dark theme" class="dark-mode-toggle_wrapper__bHDaz"><svg fill="#000000" data-theme="light" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="dark-mode-toggle_toggle__2rc2d dark-mode-toggle_toggleDark__2f6wj"><path d="M0 0h24v24H0z" fill="none"></path><path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path></svg><svg fill="#000000" data-theme="dark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="dark-mode-toggle_toggle__2rc2d dark-mode-toggle_toggleLight__1OB2p"><path d="M0 0h24v24H0z" fill="none"></path><path d="M9.5,2c-1.82,0-3.53,0.5-5,1.35c2.99,1.73,5,4.95,5,8.65s-2.01,6.92-5,8.65C5.97,21.5,7.68,22,9.5,22c5.52,0,10-4.48,10-10 S15.02,2,9.5,2z"></path></svg></div></nav></div></div></header><main class="layout_content__2V5t2"><article class="post_post__2uzyE"><h1 class="heading_container__2UElk"><a href="/blog/codi-vim-fullscreen-buffer" class="heading_link__1aoFY">Codi.vim + fullscreen buffer</a></h1><span class="post_postData__yktVb text_page-accent-fg__3pARq">By Sidney Liebrand on Aug, 2018<span class="bullet_bullet__2pnOU">â€¢</span>5 min read</span><section><div><figure class="wide media_figure__1BF98"><div style="padding-bottom: 58.133971291866025%;" class="media_relative__3Dzxp"><img loading="lazy" src="/media/posts/codi-banner.png" alt="A Codi.vim fullscreen buffer" class="media_media__1ZpPG" /></div><figcaption class="media_alt__xSx7S">A Codi.vim fullscreen buffer</figcaption></figure><p>Recently I discovered <a href="https://github.com/metakirby5/codi.vim" title="Visit metakirby5/codi.vim on GitHub">codi.vim</a> on <a href="https://vimawesome.com/?q=cat%3Aother" title="Visit vimawesome.com 'Other' category plugin">vimawesome.com</a>.
It sells itself as an &quot;interactive scratchpad for hackers&quot;.
After playing around with it for 5 minutes I was completely sold.</p><p>I pair program on a weekly basis using various different languages.
I used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.
Making a typo in the middle of a <code>do ... end</code> block in Ruby is quite costly:</p><figure class="media_figure__1BF98"><div style="padding-bottom: 24.20135527589545%;" class="media_relative__3Dzxp"><video autoPlay loop muted playsInline class="media_media__1ZpPG"><source src="/media/posts/pry-multiline-typo.webm" type="video/webm" /><source src="/media/posts/pry-multiline-typo.mp4" type="video/mp4" /></video></div><figcaption class="media_alt__xSx7S">Multiline expression typo in Pry</figcaption></figure><p>Another thing to note here is that code and results are printed sequentially.
This means that any code you write goes off-screen at least twice as fast because the result is printed below it.</p><p>In case of errors and stack traces it can become a lot worse as well.
Codi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:</p><figure class="media_figure__1BF98"><div style="padding-bottom: 13.649564375605033%;" class="media_relative__3Dzxp"><video autoPlay loop muted playsInline class="media_media__1ZpPG"><source src="/media/posts/ruby-demo.webm" type="video/webm" /><source src="/media/posts/ruby-demo.mp4" type="video/mp4" /></video></div><figcaption class="media_alt__xSx7S">Demo of Ruby in Codi.vim</figcaption></figure><p>This feature, and the fact that I can toggle this buffer for <em>multiple programming languages</em> using a single mapping blew my mind but as with anything,
it requires some more battle testing to see if it works in common scenario's.</p><h2 class="heading_container__2UElk"><a id="battle-testing" class="heading_anchor__PWj4r"></a><a href="#battle-testing" class="heading_link__1aoFY">Battle testing</a></h2><p>This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:</p><figure class="media_figure__1BF98"><div style="padding-bottom: 48.01548886737657%;" class="media_relative__3Dzxp"><video autoPlay loop muted playsInline class="media_media__1ZpPG"><source src="/media/posts/split-behavior.webm" type="video/webm" /><source src="/media/posts/split-behavior.mp4" type="video/mp4" /></video></div><figcaption class="media_alt__xSx7S">Default split behavior</figcaption></figure><p>At this point I started experimenting with a small <a href="https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e" title="Visit codi.vim snippet github gist">vimscript snippet</a> in my .vimrc.
Excluding comments and blanks it is 10 LoC.
It wraps the default <code>Codi</code> command in a function which creates an empty buffer in a new tab with the right filetype set before finally running <code>Codi</code> itself.
This creates the fullscreen split that I wanted:</p><figure class="media_figure__1BF98"><div style="padding-bottom: 48.01548886737657%;" class="media_relative__3Dzxp"><video autoPlay loop muted playsInline class="media_media__1ZpPG"><source src="/media/posts/wrapped-split-behavior.webm" type="video/webm" /><source src="/media/posts/wrapped-split-behavior.mp4" type="video/mp4" /></video></div><figcaption class="media_alt__xSx7S">Enhanced split behavior</figcaption></figure><h2 class="heading_container__2UElk"><a id="problem-solved-or-maybe-not" class="heading_anchor__PWj4r"></a><a href="#problem-solved-or-maybe-not" class="heading_link__1aoFY">Problem solved, or maybe not?</a></h2><p>All good so far, but upon closing the buffer, the contents of the buffer are deleted.
While automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.</p><p>This required a <a href="https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62" title="Visit second codi.vim snippet github gist">second iteration</a> of the original vimscript snippet.
This time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.
After hiding the buffer, its <code>tabpagenr()</code> is stored in a dictionary keyed by the filetype of the buffer.</p><p>Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):</p><figure class="media_figure__1BF98"><div style="padding-bottom: 48.01548886737657%;" class="media_relative__3Dzxp"><video autoPlay loop muted playsInline class="media_media__1ZpPG"><source src="/media/posts/wrapped-split-behavior-2.webm" type="video/webm" /><source src="/media/posts/wrapped-split-behavior-2.mp4" type="video/mp4" /></video></div><figcaption class="media_alt__xSx7S">Enhanced split behavior version 2</figcaption></figure><p>And there we go! Aside from the fact that the buffer now remains, the name is also <code>scratch::ruby</code>.
This is a bit more descriptive than having just <code>[Scratch]</code> in <code>:ls</code> output when multiple codi buffers of a different filetype are active.</p><h2 class="heading_container__2UElk"><a id="let-s-wrap-it-in-an-issue" class="heading_anchor__PWj4r"></a><a href="#let-s-wrap-it-in-an-issue" class="heading_link__1aoFY">Let's wrap it in an issue</a></h2><p>It was a fun experience tweaking this plugin to my liking.
I thought this feature would be so awesome that I even proposed it in an <a href="https://github.com/metakirby5/codi.vim/issues/94" title="View metakirby5/codi.vim issue #94">issue</a>.
Unfortunately it didn't make it since it was too workflow specific.</p><p>As you may have been able to see in the issue though, the code in that snippet is <em>slighty</em> different from the example gist linked in this post.
The main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:</p><pre style="background-color: #2a2734; color: #9a86fd;" class="prism-code language-viml"><div style="color: #9a86fd;" class="token-line"><span style="color: #9390a1;" class="token comment">&quot; since it is fullscreen, I'd like a 50/50 split</span><span class="token plain"></span></div><div style="color: #9a86fd;" class="token-line"><span class="token plain"></span><span style="color: #ffcc99;" class="token keyword">let</span><span class="token plain"> g</span><span style="color: #6c6783;" class="token punctuation">:</span><span class="token plain">codi</span><span style="color: #6c6783;" class="token punctuation">#</span><span class="token plain">width </span><span style="color: #e09142;" class="token operator">=</span><span class="token plain"> </span><span style="color: #fa60c3;" class="token function">winwidth</span><span style="color: #6c6783;" class="token punctuation">(</span><span style="color: #fa60c3;" class="token function">winnr</span><span style="color: #6c6783;" class="token punctuation">(</span><span style="color: #6c6783;" class="token punctuation">)</span><span style="color: #6c6783;" class="token punctuation">)</span><span class="token plain"> </span><span style="color: #e09142;" class="token operator">/</span><span class="token plain"> </span><span style="color: #e09142;" class="token number">2</span></div></pre><p>The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.
So I went ahead and <a href="https://github.com/metakirby5/codi.vim/pull/95" title="View metakirby5/codi.vim pull request #95">wrote a PR</a> for that instead, this is why you see
<code>let g:codi#width = 50.0</code> in the gists :)</p><h2 class="heading_container__2UElk"><a id="conclusion" class="heading_anchor__PWj4r"></a><a href="#conclusion" class="heading_link__1aoFY">Conclusion</a></h2><p>All in all it was a great experience discovering this plugin.
It is like one of those rare cases with a song where after a few seconds <strong>you just know</strong> <em>&quot;this song is awesome&quot;</em>.
I believe I'll be using it for a long time to come for quickly testing and showing some code.</p><p>This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.
Something which I wanted to do for a long time but couldn't really find the right project to contribute to.
I want to thank <a href="https://medium.com/@metakirby5" title="View @metakirby5 on Medium">Ethan Chan</a> for his awesome plugin and for being a kind and friendly maintainer!</p><p>That's it! If you want a fullscreen workflow with codi.vim, you have it.
If you want to persist the code in the buffer, you have it.
If you have a great idea, comment on this post!</p><p>Until next time.</p><p>ðŸ‘‹</p></div></section><a tabIndex="0" class="button_button__LVJFE" href="/">Back</a></article></main><footer class="layout_footer__2cV3b"><strong>Â©</strong> sidneyliebrand.io 2021</footer></div></div></body></html>