<!DOCTYPE html><html lang="en"><head><script>
                        try {
                            var theme = localStorage.getItem('theme');
                            if (theme) {
                                var html = document.querySelector('html');
                                var style = document.createElement('style');
                                var themes = {"default":{"page-bg":"#fff","page-fg":"#000","page-accent-fg":"#666","header-shadow":"#ccc","primary-bg":"#651eea","primary-fg":"#ffffff","inline-code-bg":"#e8e8e8","inline-code-fg":"#444","kbd-bg":"#fff","kbd-fg":"#555","addition-fg":"#00852c","deletion-fg":"#d33947","star-fg":"#bf9a00","tag-bg":"#fafafa","tag-fg":"#727272","link-fg":"#651eea","selection-bg":"rgba(101, 30, 234, 0.2)"},"dark":{"page-bg":"#111","page-fg":"#eee","page-accent-fg":"#aaa","header-shadow":"#333","primary-bg":"#834de8","primary-fg":"#ffffff","inline-code-bg":"#666","inline-code-fg":"#e8e8e8","kbd-bg":"#666","kbd-fg":"#e8e8e8","addition-fg":"#00cc00","deletion-fg":"#ff0000","star-fg":"#f2d043","tag-bg":"#666","tag-fg":"#e8e8e8","link-fg":"#a676ff","selection-bg":"rgba(131, 77, 232, 0.4)"}};

                                html.setAttribute('class', theme);
                                style.innerHTML = 'html { background-color:' + themes[theme]['page-bg'] + '; }';

                                document.head.appendChild(style);
                            }
                        } catch (e) {
                        }
                    </script><meta charSet="utf-8"/><title>How FZF and ripgrep improved my workflow</title><link rel="cannonical" href="https://sidneyliebrand.io/blog/how-fzf-and-ripgrep-improved-my-workflow"/><link rel="manifest" href="/site.webmanifest"/><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#a676ff"/><link rel="icon" sizes="48x48" type="image/icon" href="/favicon.ico"/><link rel="icon" sizes="16x16" type="image/png" href="/favicon-16x16.png"/><link rel="icon" sizes="32x32" type="image/png" href="/favicon-32x32.png"/><link rel="apple-touch-icon" sizes="180x180" type="image/png" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" title="The official https://sidneyliebrand.io Atom feed" href="/atom.xml"/><link rel="alternate" type="application/rss+xml" title="The official https://sidneyliebrand.io RSS feed" href="/feed.xml"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="theme-color" content="#ffffff"/><meta name="msapplication-TileColor" content="#ffc40d"/><meta name="robots" content="index, follow"/><meta name="author" content="Sidney Liebrand"/><meta name="description" content="In my never ending quest for simplicity I recently discovered FZF and ripgrep. Two command-line tools that have the potential to make every dag programming tasks easier. In this post I will explain how I use these tools to do things in a matter of keystrokes rather than having to re-google that command you keep forgetting &lt;strong&gt;every. single. time.&lt;/strong&gt;."/><meta property="og:title" content="How FZF and ripgrep improved my workflow"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sidneyliebrand.io"/><meta property="og:site_name" content="https://sidneyliebrand.io"/><meta property="og:description" content="In my never ending quest for simplicity I recently discovered FZF and ripgrep. Two command-line tools that have the potential to make every dag programming tasks easier. In this post I will explain how I use these tools to do things in a matter of keystrokes rather than having to re-google that command you keep forgetting &lt;strong&gt;every. single. time.&lt;/strong&gt;."/><meta name="dc:creator" content="Sidney Liebrand"/><meta name="dc:title" content="How FZF and ripgrep improved my workflow"/><meta name="dc:description" content="In my never ending quest for simplicity I recently discovered FZF and ripgrep. Two command-line tools that have the potential to make every dag programming tasks easier. In this post I will explain how I use these tools to do things in a matter of keystrokes rather than having to re-google that command you keep forgetting &lt;strong&gt;every. single. time.&lt;/strong&gt;."/><meta name="twitter:card" content="summary"/><meta name="twitter:creator" content="@scbydoooo"/><meta name="next-head-count" content="27"/><link rel="preload" href="/_next/static/css/d5d69cc2a1c03838ae40.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d5d69cc2a1c03838ae40.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a3d6910a7b0c03fb2f1a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a3d6910a7b0c03fb2f1a.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-25074903459b76ecf3d7.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.29f9e2f3d4a33bafbaa5.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8605d6b0be09876fb5ed.js" as="script"/><link rel="preload" href="/_next/static/chunks/62e1beb3a59d93297dd568d6addecfcbe54736d1.aa64992a2bd5287741c5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3951d5f435ad98bbfb01.js" as="script"/><link rel="preload" href="/_next/static/chunks/89c7192737f5dae381690d2d2c3016603346826c.3fe8d6de12c9023523b3.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bslug%5D-9b59dd61cc9c9ff95369.js" as="script"/></head><body><div id="__next"><div class="layout_application__6A4un"><header class="layout_header__3bVjw"><div class="layout_headerFixed__3v8Yi"><div class="layout_headerContent__18ocK"><a class="layout_logo__319hZ" title="View home page" href="/"><span class="layout_logoTopLeft__2TXmp"></span><span class="layout_logoBottomLeft__1VwSz"></span><span class="layout_logoTopRight__36KVG"></span><span class="layout_logoBottomRight__34Roq"></span></a><nav class="layout_navigation__19PAD"><a title="View curriculum vitae" href="/cv">C.V.</a><a title="Visit Sidney Liebrand&#x27;s GitHub page" href="https://github.com/SidOfc"><figure class="layout_github__23ZLB media_figure__1BF98 media_invertDark__1FMJX"><div class="lazyload-wrapper "><div style="padding-bottom:100%"></div></div></figure></a><div tabindex="0" title="Toggle dark theme" class="dark-mode-toggle_wrapper__bHDaz"><svg fill="#000000" class="dark-mode-toggle_toggle__2rc2d dark-mode-toggle_toggleDark__2f6wj" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path></svg><svg fill="#000000" class="dark-mode-toggle_toggle__2rc2d dark-mode-toggle_toggleLight__1OB2p" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"></path><path d="M9.5,2c-1.82,0-3.53,0.5-5,1.35c2.99,1.73,5,4.95,5,8.65s-2.01,6.92-5,8.65C5.97,21.5,7.68,22,9.5,22c5.52,0,10-4.48,10-10 S15.02,2,9.5,2z"></path></svg></div></nav></div></div></header><main class="layout_content__2V5t2"><article class="post_post__2uzyE"><h1 class="heading_container__2UElk"><a class="heading_link__1aoFY" href="/blog/how-fzf-and-ripgrep-improved-my-workflow">How FZF and ripgrep improved my workflow</a></h1><span class="post_postData__yktVb text_page-accent-fg__3pARq">By Sidney Liebrand on <!-- -->Jun, 2018<span class="bullet_bullet__2pnOU">â€¢</span>11<!-- --> min read</span><div><p>Today I want to talk about <a href="https://github.com/junegunn/fzf" title="Visit junegunn/fzf on GitHub">fzf</a> and <a href="https://github.com/BurntSushi/ripgrep" title="Visit BurntSushi/ripgrep on github">ripgrep</a>,
two tools I use all the time when working in Vim and the terminal.
They have become an absolutely <strong>vital</strong> part of my workflow.
Ever since I started using them I can&#x27;t imagine myself functioning
without them anymore.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="what-is-fzf"></a><a class="heading_link__1aoFY" href="#what-is-fzf">What is FZF?</a></h2><p>FZF is a fuzzy finder for your terminal, it is a command line application that
filters each line from given input with a query that the user types.
When the query changes, the results update in realtime.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:23.4375%"></div></div><figcaption class="media_alt__xSx7S">FZF + LS example</figcaption></figure><p>After finding the file you&#x27;re looking for, hitting <kbd>enter</kbd> prints the highlighted
entry. You can combine this with your <code>$EDITOR</code> variable to search for a file and then edit
it for example.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:23.4375%"></div></div><figcaption class="media_alt__xSx7S">Open CHANGELOG.md in NeoVim</figcaption></figure><p>Of course this is only a simple example. The possibilities with FZF are endless.
There are countless ways in which you can use it to filter input and use that in
another command. We&#x27;ll dive more into that later.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="what-about-ripgrep"></a><a class="heading_link__1aoFY" href="#what-about-ripgrep">What about ripgrep?</a></h2><p>As it already says in the name, it is another <code>grep</code> program. Ripgrep is written
in rust and one of its primary goals is to be the <em>fastest</em> <code>grep</code> of them all.
It performs amazing even in a larger code base.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:23.4375%"></div></div><figcaption class="media_alt__xSx7S">Ripgrep list files with FZF</figcaption></figure><p>Ripgrep has many options to explore, there are way to many to list here.
Some of the options I use most often with ripgrep are:</p><ul><li><p><code>--files</code> <!-- -->â€”<!-- --> List files which ripgrep will search instead of searching them</p></li><li><p><code>--hidden</code> <!-- -->â€”<!-- --> Show hidden (<code>.file</code>) files</p></li><li><p><code>--no-ignore-vcs</code> <!-- -->â€”<!-- --> Show files ignored by your VCS</p></li><li><p><code>--vimgrep</code> <!-- -->â€”<!-- --> Results are returned on a single line in vimgrep format</p></li></ul><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="the-problems-they-solve"></a><a class="heading_link__1aoFY" href="#the-problems-they-solve">The problems they solve</a></h2><p>Both these tools can be combined in various scenario&#x27;s that would have otherwise
taken multiple long commands to execute. This ranges from killing processes to
managing plugins to being able to find (in) files.</p><p>These actions are usually involved when I try to do something more complex:</p><ul><li><p>googling the right command</p></li><li><p>look around for the right line in the output</p></li><li><p>refine <code>grep</code> pattern</p></li><li><p>retrying the command</p></li></ul><p>At this point you&#x27;ll realize that you&#x27;re not actually searching for something
anymore. You find yourself looking for ways to perform your search instead :/</p><p>My solution to <strike>not being able</strike> being too lazy to memorize these commands is to create
small shell wrappers for them. I learn / read docs on a command to figure out how to
apply it for my use case(s). Then I write the wrapper based on the ideas I have about
how it should work.</p><p>With that being said, let&#x27;s dive right in with a common case:</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="killing-processes"></a><a class="heading_link__1aoFY" href="#killing-processes">Killing processes</a></h2><p>One example is stopping an out of control process. First you have to find the
process ID by issuing some command like <code>ps -ef | grep [PROCESS NAME]</code>.</p><p>Which is then followed by a <code>kill</code> command with one of the process IDs you want
to kill. The downsides to this are that I have to use two commands. Filter the
output before seeing it or knowing how it looks and issuing an extra command
to actually stop the process.</p><p>To make this easier, I wrote a small wrapper (first in <a href="https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/kp" title="View kp zsh script">zsh</a>,
later migrated to <a href="https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/kp.fish" title="View kp fish script">fish</a>) called <code>kp</code>.
It lists processes using <code>ps -ef</code> and pipes it to <code>fzf</code>.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:23.4375%"></div></div><figcaption class="media_alt__xSx7S">Killing processes using kp</figcaption></figure><p>This command opens an FZF window with your processes. FZF has an option to allow
selecting multiple entries (<code>-m flag</code>). When <kbd>enter</kbd> is pressed, both marked
(light red <code>&gt;</code> symbols) processes will be shut down. When changing your query,
selected entries will stay selected. This is convenient for killing different
processes in a single run.</p><p>After killing some processes, the command will rerun itself. I can use <kbd>escape</kbd> to
exit from this specific window.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="installing-brew-plugins"></a><a class="heading_link__1aoFY" href="#installing-brew-plugins">Installing brew plugins</a></h2><p>Another use case is to install, update or purge <a href="https://github.com/Homebrew" title="Visit Homebrew on GitHub">brew</a>
plugins from your system. When you are looking for a brew package, a common pattern
is to use <code>brew search</code> together with <code>grep</code> to find out if it exists.</p><p>After that you&#x27;ll most likely run a command like: <code>brew install [PACKAGE]</code> to install it.
Another pattern is to use the <code>brew leaves</code> command to list installed packages which can
be updated or removed.</p><p>I created a small wrapper for each of these actions. One for installing,
another for updating and one for deleting brew packages:</p><ul><li><p><code>bip</code> <!-- -->â€”<!-- --> <strong>B</strong><em>rew</em> <strong>I</strong><em>nstall</em> <strong>P</strong><em>lugin</em>, install one or more plugins (<a href="https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bip" title="View bip zsh script">zsh</a>, <a href="https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bip.fish" title="View bip fish script">fish</a>)</p></li><li><p><code>bup</code> <!-- -->â€”<!-- --> <strong>B</strong><em>rew</em> <strong>U</strong><em>pdate</em> <strong>P</strong><em>lugin</em>, update multiple installed plugins (<a href="https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bup" title="View bup zsh script">zsh</a>, <a href="https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bup.fish" title="View bup fish script">fish</a>)</p></li><li><p><code>bcp</code> <!-- -->â€”<!-- --> <strong>B</strong><em>rew</em> <strong>C</strong><em>lean</em> <strong>P</strong><em>lugin</em>, delete multiple installed plugins (<a href="https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bcp" title="View bcp zsh script">zsh</a>, <a href="https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bcp.fish" title="View bcp fish script">fish</a>)</p></li></ul><p>Whenever I have to do anything with brew, it is completely painless and it
works quite well for package discovery too.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:23.4375%"></div></div><figcaption class="media_alt__xSx7S">Brew Install Plugin interface</figcaption></figure><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="finding-binaries"></a><a class="heading_link__1aoFY" href="#finding-binaries">Finding binaries</a></h2><p>One mythical beast known to anyone who has ever worked in a terminal is the <code>$PATH</code>
variable. Often, a shell script will tell you to &quot;Add me to your $PATH&quot; so that the
script will become available in your shell. This makes sense but can leave you with
a messed up shell path or duplicate entries. It could cause all kinds of weirdness
and slowness in your terminal.</p><p>My solution to this is a simple path explorer called <code>fp</code> (<a href="https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/fp" title="View fp zsh script">zsh</a>, <a href="https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/fp.fish" title="View fp fish script">fish</a>).
It invokes FZF with a list of folders populated using <code>$PATH</code>.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:23.4375%"></div></div><figcaption class="media_alt__xSx7S">Directories present in $PATH</figcaption></figure><p>Of course there are more than 3 paths in my list but I cropped the gif for brevity here.
When I press <kbd>enter</kbd> on the <code>/bin</code> entry, I see a list of executables inside that folder.
Either find what you&#x27;re looking for or go back.</p><p>Going back to the overview is as easy as pressing <kbd>escape</kbd>. This will take you back to
the directory listing. Pressing <kbd>escape</kbd> in the overview will exit the command completely.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="checking-features-on-caniuse"></a><a class="heading_link__1aoFY" href="#checking-features-on-caniuse">Checking features on caniuse.com</a></h2><p>Additionally, I&#x27;ve written a post before on how to <a href="/blog/combining-caniuse-with-fzf" title="Read the &#x27;combine Caniuse with FZF post&#x27;">combine Caniuse with FZF</a>.
It allows me to quickly find out whether I should stay away from some Web API or not.
this small tool also allows me to query features that have been added or deprecated recently.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:23.4375%"></div></div><figcaption class="media_alt__xSx7S">An example of looking for features using cani</figcaption></figure><p>The <code>cani</code> command (<a href="https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/cani" title="View cani zsh script">zsh</a>, <a href="https://github.com/SidOfc/dotfiles/blob/1e07bc882e64cc22783ac8ec2a01651503ecc7b3/.config/fish/functions/cani.fish" title="View cani fish script">fish</a>) itself uses another <a href="https://github.com/SidOfc/dotfiles/blob/653c0331b3bd8a3b6fb5fbff0531f038e7eb5b12/bin/ciu" title="View ciu ruby script">ruby script</a>
(<code>ciu</code>) I wrote to actually provide the data and format it properly.
The data is fetched once then cached for a day.
So you&#x27;ll have fresh data on a daily basis :)</p><p><em>This mixture of shell + ruby has since been <a href="https://github.com/SidOfc/cani" title="View SidOfc/cani on GitHub">ported</a> to a <a href="https://rubygems.org/gems/cani" title="View cani gem on rubygems.org">Ruby Gem</a> :)</em></p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="vim"></a><a class="heading_link__1aoFY" href="#vim">Vim</a></h2><p>Since I spend a lot of my time in Vim trying to find a file either by name,
or by some code <em>inside</em> a certain file. Streamlining that process is very important.
Every context switch you have to make adds overhead and the possibility of losing
focus of what you are trying to find. Therefore it should be as mindless as possible,
e.g: press a key, type query, press enter to go to matching file.</p><p>Finding files wasn&#x27;t too much of an issue here. There is a long list of Vim plugins
that offer file searching using fuzzy matching or <a href="https://en.wikipedia.org/wiki/Most_Recently_Used" title="Visit Most Recently Used definition on wikipedia.org">MRU</a> algorithms. Two examples of this are <a href="https://github.com/ctrlpvim/ctrlp.vim" title="Visit ctrlpvim/ctrlp.vim on GitHub">CtrlP</a> and <a href="https://github.com/wincent/command-t" title="Visit wincent/command-t on github">Command-T</a>.
I used CtrlP which always managed to do the job. But after playing around with FZF
in the terminal I wondered if it could be applied to Vim as well.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="fzf"></a><a class="heading_link__1aoFY" href="#fzf">FZF.vim</a></h2><p><a href="https://github.com/junegunn/fzf.vim" title="Visit junegunn/fzf.vim on GitHub">FZF</a> has a small builtin Vim interface that already works, but it comes without
any existing functionality. The author of FZF also wrote this plugin.
It is a small wrapper that provides common functionality. This includes listing files,
buffers, tags, git logs and much more!</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="fuzzy-searching-in-file-paths"></a><a class="heading_link__1aoFY" href="#fuzzy-searching-in-file-paths">Fuzzy searching in file paths</a></h2><p>Coming from CtrlP the first thing I needed was a replacement for fuzzy-finding files.
The solution was to use the <code>:Files</code> command provided by FZF.vim. This lists files
using your <code>$FZF_DEFAULT_COMMAND</code> environment variable. It opens the currently
highlighted file on <kbd>enter</kbd>.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:68.0648236415634%"></div></div><figcaption class="media_alt__xSx7S">FZF :Files demo</figcaption></figure><p>Since I was already so used to the <kbd>ctrl</kbd>+<kbd>p</kbd> mapping from the CtrlP plugin,
I mapped the <code>:Files</code> command to it: <code>nnoremap &lt;C-p&gt; :Files&lt;Cr&gt;</code>.</p><p>FZF will not use ripgrep by default so you&#x27;ll have to modify <code>$FZF_DEFAULT_COMMAND</code>
if you want FZF to use ripgrep. Of course this is exactly what I wanted!
After some tweaking I ended up with the following command:</p><ul><li><p><strong>Fish syntax:</strong> <code>set -gx FZF_DEFAULT_COMMAND &#x27;rg --files --no-ignore-vcs --hidden&#x27;</code></p></li><li><p><strong>Bash / ZSH syntax:</strong> <code>export FZF_DEFAULT_COMMAND=&#x27;rg --files --no-ignore-vcs --hidden&#x27;</code></p></li></ul><p>In my case it happens that I do want to edit or search for something in a file
that is ignored by my VCS or in a hidden file. The options ensure that all files
inside the directory are listed (except those ignored in a <code>~/.rgignore</code> file).</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="finding-content-in-specific-files"></a><a class="heading_link__1aoFY" href="#finding-content-in-specific-files">Finding content in specific files</a></h2><p>Last but not least I wanted to find files based on what was inside of a file.
This is useful to see where a class or function is used for example.</p><figure class="media_figure__1BF98"><div class="lazyload-wrapper "><div style="padding-bottom:68.0648236415634%"></div></div><figcaption class="media_alt__xSx7S">FZF :Rg demo</figcaption></figure><p>The name of this command is <code>:Rg</code> which already uses <code>ripgrep</code> in the background! Done right?
Nope <!-- -->â€”<!-- --> after playing around I noticed that while <code>:Rg</code> indeed searches the file&#x27;s
<em>contents</em>, it also matches the <em>file name</em> shown in the list like <code>:Files</code> does (exclusively).</p><p>In my brain these concepts are completely isolated from each other:</p><p>When I need to find a specific <em>file</em> I <em>know</em> that I&#x27;m looking for a <em>filename</em> in
which case I do not want to search <em>inside</em> the file.</p><p>On the other hand, when I need to find a specific area of known code or figure out
in which files a certain class is used, I am most certainly never interested in matches from filenames.</p><p>To achieve what I wanted, I had to override the default behavior.
An <a href="https://github.com/junegunn/fzf.vim/issues/346" title="Visit junegunn/fzf.vim issue #346">issue</a> was created for the
exact same reason for the <code>:Ag</code> command. Based on <a href="https://github.com/junegunn/fzf.vim/issues/346#issuecomment-288483704" title="Visit junegunn/fzf.vim issue #346 issue comment">this comment</a>
I came up with the following setup to accomplish this:</p><pre class="prism-code language-viml" style="background-color:#2a2734;color:#9a86fd"><div class="token-line" style="color:#9a86fd"><span class="token plain">command</span><span class="token operator" style="color:#e09142">!</span><span class="token plain"> </span><span class="token operator" style="color:#e09142">-</span><span class="token plain">bang </span><span class="token operator" style="color:#e09142">-</span><span class="token plain">nargs</span><span class="token operator" style="color:#e09142">=</span><span class="token operator" style="color:#e09142">*</span><span class="token plain"> Rg</span></div><div class="token-line" style="color:#9a86fd"><span class="token plain">  </span><span class="token punctuation" style="color:#6c6783">\</span><span class="token plain"> </span><span class="token keyword" style="color:#ffcc99">call</span><span class="token plain"> fzf</span><span class="token punctuation" style="color:#6c6783">#</span><span class="token plain">vim</span><span class="token punctuation" style="color:#6c6783">#</span><span class="token function" style="color:#fa60c3">grep</span><span class="token punctuation" style="color:#6c6783">(</span><span class="token plain"></span></div><div class="token-line" style="color:#9a86fd"><span class="token plain">  </span><span class="token punctuation" style="color:#6c6783">\</span><span class="token plain">   </span><span class="token string" style="color:#ffcc99">&#x27;rg --column --line-number --hidden --ignore-case --no-heading --color=always &#x27;</span><span class="token operator" style="color:#e09142">.</span><span class="token function" style="color:#fa60c3">shellescape</span><span class="token punctuation" style="color:#6c6783">(</span><span class="token operator" style="color:#e09142">&lt;</span><span class="token keyword" style="color:#ffcc99">q</span><span class="token operator" style="color:#e09142">-</span><span class="token keyword" style="color:#ffcc99">args</span><span class="token operator" style="color:#e09142">&gt;</span><span class="token punctuation" style="color:#6c6783">)</span><span class="token punctuation" style="color:#6c6783">,</span><span class="token plain"> </span><span class="token number" style="color:#e09142">1</span><span class="token punctuation" style="color:#6c6783">,</span><span class="token plain"></span></div><div class="token-line" style="color:#9a86fd"><span class="token plain">  </span><span class="token punctuation" style="color:#6c6783">\</span><span class="token plain">   </span><span class="token operator" style="color:#e09142">&lt;</span><span class="token plain">bang</span><span class="token operator" style="color:#e09142">&gt;</span><span class="token number" style="color:#e09142">0</span><span class="token plain"> </span><span class="token operator" style="color:#e09142">?</span><span class="token plain"> fzf</span><span class="token punctuation" style="color:#6c6783">#</span><span class="token plain">vim</span><span class="token punctuation" style="color:#6c6783">#</span><span class="token function" style="color:#fa60c3">with_preview</span><span class="token punctuation" style="color:#6c6783">(</span><span class="token punctuation" style="color:#6c6783">{</span><span class="token string" style="color:#ffcc99">&#x27;options&#x27;</span><span class="token punctuation" style="color:#6c6783">:</span><span class="token plain"> </span><span class="token string" style="color:#ffcc99">&#x27;--delimiter : --nth 4..&#x27;</span><span class="token punctuation" style="color:#6c6783">}</span><span class="token punctuation" style="color:#6c6783">,</span><span class="token plain"> </span><span class="token string" style="color:#ffcc99">&#x27;up:60%&#x27;</span><span class="token punctuation" style="color:#6c6783">)</span><span class="token plain"></span></div><div class="token-line" style="color:#9a86fd"><span class="token plain">  </span><span class="token punctuation" style="color:#6c6783">\</span><span class="token plain">           </span><span class="token punctuation" style="color:#6c6783">:</span><span class="token plain"> fzf</span><span class="token punctuation" style="color:#6c6783">#</span><span class="token plain">vim</span><span class="token punctuation" style="color:#6c6783">#</span><span class="token function" style="color:#fa60c3">with_preview</span><span class="token punctuation" style="color:#6c6783">(</span><span class="token punctuation" style="color:#6c6783">{</span><span class="token string" style="color:#ffcc99">&#x27;options&#x27;</span><span class="token punctuation" style="color:#6c6783">:</span><span class="token plain"> </span><span class="token string" style="color:#ffcc99">&#x27;--delimiter : --nth 4..&#x27;</span><span class="token punctuation" style="color:#6c6783">}</span><span class="token punctuation" style="color:#6c6783">,</span><span class="token plain"> </span><span class="token string" style="color:#ffcc99">&#x27;right:50%:hidden&#x27;</span><span class="token punctuation" style="color:#6c6783">,</span><span class="token plain"> </span><span class="token string" style="color:#ffcc99">&#x27;?&#x27;</span><span class="token punctuation" style="color:#6c6783">)</span><span class="token punctuation" style="color:#6c6783">,</span><span class="token plain"></span></div><div class="token-line" style="color:#9a86fd"><span class="token plain">  </span><span class="token punctuation" style="color:#6c6783">\</span><span class="token plain">   </span><span class="token operator" style="color:#e09142">&lt;</span><span class="token plain">bang</span><span class="token operator" style="color:#e09142">&gt;</span><span class="token number" style="color:#e09142">0</span><span class="token punctuation" style="color:#6c6783">)</span></div></pre><p>This one I mapped to <kbd>ctrl</kbd>+<kbd>g</kbd>, right next to <kbd>ctrl</kbd>+<kbd>f</kbd>
for the <code>:Files</code> command: <code>nnoremap &lt;C-g&gt; :Rg&lt;Cr&gt;</code></p><p>The nice thing about this command is that you can select multiple files.
When selecting multiple files, pressing <kbd>enter</kbd> will load the files in a
quickfix list for batch editing using <code>cdo</code> for example.</p><h2 class="heading_container__2UElk"><a class="heading_anchor__PWj4r" id="conclusion"></a><a class="heading_link__1aoFY" href="#conclusion">Conclusion</a></h2><p>As I mentioned at the start of my post, these tools have become a <strong>vital</strong>
part of my workflow. I use them while barely noticing their presence and they
take a lot of complexity away from the task at hand. This allows me to focus
on what matters instead of finding out how to do something which should be trivial.</p><p>Whether it be killing services / processes, installing brew packages,
finding a glitch in my path or a feature set in caniuse, I can do it in fewer
keystrokes with more fine-grained control. I even use FZF as a standalone
filter sometimes when I have to find something in line-based command output,
skipping (rip)grep all together :)</p><p>Hopefully you are also able to reduce some of the strain in your workflow with
FZF using some of the tips above. If you are using FZF in another way, leave a
comment! I&#x27;d love to hear about it and learn what others are doing with these
two fantastic tools.</p><p>Happy fuzzy finding :)</p><p>ðŸ‘‹</p></div><a tabindex="0" class="button_button__LVJFE" href="/">Back</a></article></main><footer class="layout_footer__2cV3b"><strong>Â©</strong> sidneyliebrand.io<!-- --> <!-- -->2021</footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"How FZF and ripgrep improved my workflow","description":"In my never ending quest for simplicity I recently discovered FZF and ripgrep. Two command-line tools that have the potential to make every dag programming tasks easier. In this post I will explain how I use these tools to do things in a matter of keystrokes rather than having to re-google that command you keep forgetting \u003cstrong\u003eevery. single. time.\u003c/strong\u003e.","published":"2018-06-24T13:33:37Z","updated":"2019-07-10T21:10:00Z","readTimeInMinutes":11,"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today I want to talk about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/junegunn/fzf\",\n    \"title\": \"Visit junegunn/fzf on GitHub\"\n  }, \"fzf\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/BurntSushi/ripgrep\",\n    \"title\": \"Visit BurntSushi/ripgrep on github\"\n  }, \"ripgrep\"), \",\\ntwo tools I use all the time when working in Vim and the terminal.\\nThey have become an absolutely \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"vital\"), \" part of my workflow.\\nEver since I started using them I can't imagine myself functioning\\nwithout them anymore.\"), mdx(\"h2\", null, \"What is FZF?\"), mdx(\"p\", null, \"FZF is a fuzzy finder for your terminal, it is a command line application that\\nfilters each line from given input with a query that the user types.\\nWhen the query changes, the results update in realtime.\"), mdx(Media, {\n    src: \"/media/posts/fzf-ls-example\",\n    alt: \"FZF + LS example\",\n    width: \"768\",\n    height: \"180\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"After finding the file you're looking for, hitting \", mdx(\"kbd\", null, \"enter\"), \" prints the highlighted\\nentry. You can combine this with your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$EDITOR\"), \" variable to search for a file and then edit\\nit for example.\"), mdx(Media, {\n    src: \"/media/posts/open-changelog-neovim\",\n    alt: \"Open CHANGELOG.md in NeoVim\",\n    width: \"768\",\n    height: \"180\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"Of course this is only a simple example. The possibilities with FZF are endless.\\nThere are countless ways in which you can use it to filter input and use that in\\nanother command. We'll dive more into that later.\"), mdx(\"h2\", null, \"What about ripgrep?\"), mdx(\"p\", null, \"As it already says in the name, it is another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grep\"), \" program. Ripgrep is written\\nin rust and one of its primary goals is to be the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fastest\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grep\"), \" of them all.\\nIt performs amazing even in a larger code base.\"), mdx(Media, {\n    src: \"/media/posts/rg-ls-fzf\",\n    alt: \"Ripgrep list files with FZF\",\n    width: \"768\",\n    height: \"180\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"Ripgrep has many options to explore, there are way to many to list here.\\nSome of the options I use most often with ripgrep are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--files\"), \" \", \"\\u2014\", \" List files which ripgrep will search instead of searching them\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--hidden\"), \" \", \"\\u2014\", \" Show hidden (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".file\"), \") files\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--no-ignore-vcs\"), \" \", \"\\u2014\", \" Show files ignored by your VCS\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"--vimgrep\"), \" \", \"\\u2014\", \" Results are returned on a single line in vimgrep format\"))), mdx(\"h2\", null, \"The problems they solve\"), mdx(\"p\", null, \"Both these tools can be combined in various scenario's that would have otherwise\\ntaken multiple long commands to execute. This ranges from killing processes to\\nmanaging plugins to being able to find (in) files.\"), mdx(\"p\", null, \"These actions are usually involved when I try to do something more complex:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"googling the right command\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"look around for the right line in the output\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"refine \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grep\"), \" pattern\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"retrying the command\"))), mdx(\"p\", null, \"At this point you'll realize that you're not actually searching for something\\nanymore. You find yourself looking for ways to perform your search instead :/\"), mdx(\"p\", null, \"My solution to \", mdx(\"strike\", null, \"not being able\"), \" being too lazy to memorize these commands is to create\\nsmall shell wrappers for them. I learn / read docs on a command to figure out how to\\napply it for my use case(s). Then I write the wrapper based on the ideas I have about\\nhow it should work.\"), mdx(\"p\", null, \"With that being said, let's dive right in with a common case:\"), mdx(\"h2\", null, \"Killing processes\"), mdx(\"p\", null, \"One example is stopping an out of control process. First you have to find the\\nprocess ID by issuing some command like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ps -ef | grep [PROCESS NAME]\"), \".\"), mdx(\"p\", null, \"Which is then followed by a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kill\"), \" command with one of the process IDs you want\\nto kill. The downsides to this are that I have to use two commands. Filter the\\noutput before seeing it or knowing how it looks and issuing an extra command\\nto actually stop the process.\"), mdx(\"p\", null, \"To make this easier, I wrote a small wrapper (first in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/kp\",\n    \"title\": \"View kp zsh script\"\n  }, \"zsh\"), \",\\nlater migrated to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/kp.fish\",\n    \"title\": \"View kp fish script\"\n  }, \"fish\"), \") called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"kp\"), \".\\nIt lists processes using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ps -ef\"), \" and pipes it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fzf\"), \".\"), mdx(Media, {\n    src: \"/media/posts/kill-with-kp\",\n    alt: \"Killing processes using kp\",\n    width: \"768\",\n    height: \"180\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"This command opens an FZF window with your processes. FZF has an option to allow\\nselecting multiple entries (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-m flag\"), \"). When \", mdx(\"kbd\", null, \"enter\"), \" is pressed, both marked\\n(light red \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\u003e\"), \" symbols) processes will be shut down. When changing your query,\\nselected entries will stay selected. This is convenient for killing different\\nprocesses in a single run.\"), mdx(\"p\", null, \"After killing some processes, the command will rerun itself. I can use \", mdx(\"kbd\", null, \"escape\"), \" to\\nexit from this specific window.\"), mdx(\"h2\", null, \"Installing brew plugins\"), mdx(\"p\", null, \"Another use case is to install, update or purge \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Homebrew\",\n    \"title\": \"Visit Homebrew on GitHub\"\n  }, \"brew\"), \"\\nplugins from your system. When you are looking for a brew package, a common pattern\\nis to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"brew search\"), \" together with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"grep\"), \" to find out if it exists.\"), mdx(\"p\", null, \"After that you'll most likely run a command like: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"brew install [PACKAGE]\"), \" to install it.\\nAnother pattern is to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"brew leaves\"), \" command to list installed packages which can\\nbe updated or removed.\"), mdx(\"p\", null, \"I created a small wrapper for each of these actions. One for installing,\\nanother for updating and one for deleting brew packages:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bip\"), \" \", \"\\u2014\", \" \", mdx(\"strong\", null, \"B\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"rew\"), \" \", mdx(\"strong\", null, \"I\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"nstall\"), \" \", mdx(\"strong\", null, \"P\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lugin\"), \", install one or more plugins (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bip\",\n    \"title\": \"View bip zsh script\"\n  }, \"zsh\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bip.fish\",\n    \"title\": \"View bip fish script\"\n  }, \"fish\"), \")\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bup\"), \" \", \"\\u2014\", \" \", mdx(\"strong\", null, \"B\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"rew\"), \" \", mdx(\"strong\", null, \"U\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pdate\"), \" \", mdx(\"strong\", null, \"P\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lugin\"), \", update multiple installed plugins (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bup\",\n    \"title\": \"View bup zsh script\"\n  }, \"zsh\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bup.fish\",\n    \"title\": \"View bup fish script\"\n  }, \"fish\"), \")\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bcp\"), \" \", \"\\u2014\", \" \", mdx(\"strong\", null, \"B\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"rew\"), \" \", mdx(\"strong\", null, \"C\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lean\"), \" \", mdx(\"strong\", null, \"P\"), mdx(\"em\", {\n    parentName: \"p\"\n  }, \"lugin\"), \", delete multiple installed plugins (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bcp\",\n    \"title\": \"View bcp zsh script\"\n  }, \"zsh\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bcp.fish\",\n    \"title\": \"View bcp fish script\"\n  }, \"fish\"), \")\"))), mdx(\"p\", null, \"Whenever I have to do anything with brew, it is completely painless and it\\nworks quite well for package discovery too.\"), mdx(Media, {\n    src: \"/media/posts/bip-interface\",\n    alt: \"Brew Install Plugin interface\",\n    width: \"768\",\n    height: \"180\",\n    mdxType: \"Media\"\n  }), mdx(\"h2\", null, \"Finding binaries\"), mdx(\"p\", null, \"One mythical beast known to anyone who has ever worked in a terminal is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$PATH\"), \"\\nvariable. Often, a shell script will tell you to \\\"Add me to your $PATH\\\" so that the\\nscript will become available in your shell. This makes sense but can leave you with\\na messed up shell path or duplicate entries. It could cause all kinds of weirdness\\nand slowness in your terminal.\"), mdx(\"p\", null, \"My solution to this is a simple path explorer called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fp\"), \" (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/fp\",\n    \"title\": \"View fp zsh script\"\n  }, \"zsh\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/fp.fish\",\n    \"title\": \"View fp fish script\"\n  }, \"fish\"), \").\\nIt invokes FZF with a list of folders populated using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$PATH\"), \".\"), mdx(Media, {\n    src: \"/media/posts/dirs-in-path\",\n    alt: \"Directories present in $PATH\",\n    width: \"768\",\n    height: \"180\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"Of course there are more than 3 paths in my list but I cropped the gif for brevity here.\\nWhen I press \", mdx(\"kbd\", null, \"enter\"), \" on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/bin\"), \" entry, I see a list of executables inside that folder.\\nEither find what you're looking for or go back.\"), mdx(\"p\", null, \"Going back to the overview is as easy as pressing \", mdx(\"kbd\", null, \"escape\"), \". This will take you back to\\nthe directory listing. Pressing \", mdx(\"kbd\", null, \"escape\"), \" in the overview will exit the command completely.\"), mdx(\"h2\", null, \"Checking features on caniuse.com\"), mdx(\"p\", null, \"Additionally, I've written a post before on how to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/blog/combining-caniuse-with-fzf\",\n    \"title\": \"Read the 'combine Caniuse with FZF post'\"\n  }, \"combine Caniuse with FZF\"), \".\\nIt allows me to quickly find out whether I should stay away from some Web API or not.\\nthis small tool also allows me to query features that have been added or deprecated recently.\"), mdx(Media, {\n    src: \"/media/posts/checking-caniuse\",\n    alt: \"An example of looking for features using cani\",\n    width: \"768\",\n    height: \"180\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cani\"), \" command (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/cani\",\n    \"title\": \"View cani zsh script\"\n  }, \"zsh\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/1e07bc882e64cc22783ac8ec2a01651503ecc7b3/.config/fish/functions/cani.fish\",\n    \"title\": \"View cani fish script\"\n  }, \"fish\"), \") itself uses another \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/SidOfc/dotfiles/blob/653c0331b3bd8a3b6fb5fbff0531f038e7eb5b12/bin/ciu\",\n    \"title\": \"View ciu ruby script\"\n  }, \"ruby script\"), \"\\n(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ciu\"), \") I wrote to actually provide the data and format it properly.\\nThe data is fetched once then cached for a day.\\nSo you'll have fresh data on a daily basis :)\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This mixture of shell + ruby has since been \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://github.com/SidOfc/cani\",\n    \"title\": \"View SidOfc/cani on GitHub\"\n  }, \"ported\"), \" to a \", mdx(\"a\", {\n    parentName: \"em\",\n    \"href\": \"https://rubygems.org/gems/cani\",\n    \"title\": \"View cani gem on rubygems.org\"\n  }, \"Ruby Gem\"), \" :)\")), mdx(\"h2\", null, \"Vim\"), mdx(\"p\", null, \"Since I spend a lot of my time in Vim trying to find a file either by name,\\nor by some code \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"inside\"), \" a certain file. Streamlining that process is very important.\\nEvery context switch you have to make adds overhead and the possibility of losing\\nfocus of what you are trying to find. Therefore it should be as mindless as possible,\\ne.g: press a key, type query, press enter to go to matching file.\"), mdx(\"p\", null, \"Finding files wasn't too much of an issue here. There is a long list of Vim plugins\\nthat offer file searching using fuzzy matching or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Most_Recently_Used\",\n    \"title\": \"Visit Most Recently Used definition on wikipedia.org\"\n  }, \"MRU\"), \" algorithms. Two examples of this are \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ctrlpvim/ctrlp.vim\",\n    \"title\": \"Visit ctrlpvim/ctrlp.vim on GitHub\"\n  }, \"CtrlP\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/wincent/command-t\",\n    \"title\": \"Visit wincent/command-t on github\"\n  }, \"Command-T\"), \".\\nI used CtrlP which always managed to do the job. But after playing around with FZF\\nin the terminal I wondered if it could be applied to Vim as well.\"), mdx(\"h2\", null, \"FZF.vim\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/junegunn/fzf.vim\",\n    \"title\": \"Visit junegunn/fzf.vim on GitHub\"\n  }, \"FZF\"), \" has a small builtin Vim interface that already works, but it comes without\\nany existing functionality. The author of FZF also wrote this plugin.\\nIt is a small wrapper that provides common functionality. This includes listing files,\\nbuffers, tags, git logs and much more!\"), mdx(\"h2\", null, \"Fuzzy searching in file paths\"), mdx(\"p\", null, \"Coming from CtrlP the first thing I needed was a replacement for fuzzy-finding files.\\nThe solution was to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":Files\"), \" command provided by FZF.vim. This lists files\\nusing your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$FZF_DEFAULT_COMMAND\"), \" environment variable. It opens the currently\\nhighlighted file on \", mdx(\"kbd\", null, \"enter\"), \".\"), mdx(Media, {\n    src: \"/media/posts/fzf-files-demo\",\n    alt: \"FZF :Files demo\",\n    width: \"1049\",\n    height: \"714\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"Since I was already so used to the \", mdx(\"kbd\", null, \"ctrl\"), \"+\", mdx(\"kbd\", null, \"p\"), \" mapping from the CtrlP plugin,\\nI mapped the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":Files\"), \" command to it: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nnoremap \u003cC-p\u003e :Files\u003cCr\u003e\"), \".\"), mdx(\"p\", null, \"FZF will not use ripgrep by default so you'll have to modify \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$FZF_DEFAULT_COMMAND\"), \"\\nif you want FZF to use ripgrep. Of course this is exactly what I wanted!\\nAfter some tweaking I ended up with the following command:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Fish syntax:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set -gx FZF_DEFAULT_COMMAND 'rg --files --no-ignore-vcs --hidden'\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bash / ZSH syntax:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"export FZF_DEFAULT_COMMAND='rg --files --no-ignore-vcs --hidden'\")))), mdx(\"p\", null, \"In my case it happens that I do want to edit or search for something in a file\\nthat is ignored by my VCS or in a hidden file. The options ensure that all files\\ninside the directory are listed (except those ignored in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"~/.rgignore\"), \" file).\"), mdx(\"h2\", null, \"Finding content in specific files\"), mdx(\"p\", null, \"Last but not least I wanted to find files based on what was inside of a file.\\nThis is useful to see where a class or function is used for example.\"), mdx(Media, {\n    src: \"/media/posts/fzf-rg-demo\",\n    alt: \"FZF :Rg demo\",\n    width: \"1049\",\n    height: \"714\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"The name of this command is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":Rg\"), \" which already uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ripgrep\"), \" in the background! Done right?\\nNope \", \"\\u2014\", \" after playing around I noticed that while \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":Rg\"), \" indeed searches the file's\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"contents\"), \", it also matches the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"file name\"), \" shown in the list like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":Files\"), \" does (exclusively).\"), mdx(\"p\", null, \"In my brain these concepts are completely isolated from each other:\"), mdx(\"p\", null, \"When I need to find a specific \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"file\"), \" I \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"know\"), \" that I'm looking for a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"filename\"), \" in\\nwhich case I do not want to search \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"inside\"), \" the file.\"), mdx(\"p\", null, \"On the other hand, when I need to find a specific area of known code or figure out\\nin which files a certain class is used, I am most certainly never interested in matches from filenames.\"), mdx(\"p\", null, \"To achieve what I wanted, I had to override the default behavior.\\nAn \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/junegunn/fzf.vim/issues/346\",\n    \"title\": \"Visit junegunn/fzf.vim issue #346\"\n  }, \"issue\"), \" was created for the\\nexact same reason for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":Ag\"), \" command. Based on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/junegunn/fzf.vim/issues/346#issuecomment-288483704\",\n    \"title\": \"Visit junegunn/fzf.vim issue #346 issue comment\"\n  }, \"this comment\"), \"\\nI came up with the following setup to accomplish this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-viml\"\n  }, \"command! -bang -nargs=* Rg\\n  \\\\ call fzf#vim#grep(\\n  \\\\   'rg --column --line-number --hidden --ignore-case --no-heading --color=always '.shellescape(\u003cq-args\u003e), 1,\\n  \\\\   \u003cbang\u003e0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'up:60%')\\n  \\\\           : fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'right:50%:hidden', '?'),\\n  \\\\   \u003cbang\u003e0)\\n\")), mdx(\"p\", null, \"This one I mapped to \", mdx(\"kbd\", null, \"ctrl\"), \"+\", mdx(\"kbd\", null, \"g\"), \", right next to \", mdx(\"kbd\", null, \"ctrl\"), \"+\", mdx(\"kbd\", null, \"f\"), \"\\nfor the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":Files\"), \" command: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nnoremap \u003cC-g\u003e :Rg\u003cCr\u003e\")), mdx(\"p\", null, \"The nice thing about this command is that you can select multiple files.\\nWhen selecting multiple files, pressing \", mdx(\"kbd\", null, \"enter\"), \" will load the files in a\\nquickfix list for batch editing using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cdo\"), \" for example.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"As I mentioned at the start of my post, these tools have become a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"vital\"), \"\\npart of my workflow. I use them while barely noticing their presence and they\\ntake a lot of complexity away from the task at hand. This allows me to focus\\non what matters instead of finding out how to do something which should be trivial.\"), mdx(\"p\", null, \"Whether it be killing services / processes, installing brew packages,\\nfinding a glitch in my path or a feature set in caniuse, I can do it in fewer\\nkeystrokes with more fine-grained control. I even use FZF as a standalone\\nfilter sometimes when I have to find something in line-based command output,\\nskipping (rip)grep all together :)\"), mdx(\"p\", null, \"Hopefully you are also able to reduce some of the strain in your workflow with\\nFZF using some of the tips above. If you are using FZF in another way, leave a\\ncomment! I'd love to hear about it and learn what others are doing with these\\ntwo fantastic tools.\"), mdx(\"p\", null, \"Happy fuzzy finding :)\"), mdx(\"p\", null, \"\\uD83D\\uDC4B\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cp\u003eToday I want to talk about \u003ca href=\"https://github.com/junegunn/fzf\" title=\"Visit junegunn/fzf on GitHub\"\u003efzf\u003c/a\u003e and \u003ca href=\"https://github.com/BurntSushi/ripgrep\" title=\"Visit BurntSushi/ripgrep on github\"\u003eripgrep\u003c/a\u003e,\ntwo tools I use all the time when working in Vim and the terminal.\nThey have become an absolutely \u003cstrong\u003evital\u003c/strong\u003e part of my workflow.\nEver since I started using them I can\u0026#x27;t imagine myself functioning\nwithout them anymore.\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"what-is-fzf\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#what-is-fzf\"\u003eWhat is FZF?\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eFZF is a fuzzy finder for your terminal, it is a command line application that\nfilters each line from given input with a query that the user types.\nWhen the query changes, the results update in realtime.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:23.4375%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eFZF + LS example\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eAfter finding the file you\u0026#x27;re looking for, hitting \u003ckbd\u003eenter\u003c/kbd\u003e prints the highlighted\nentry. You can combine this with your \u003ccode\u003e$EDITOR\u003c/code\u003e variable to search for a file and then edit\nit for example.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:23.4375%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eOpen CHANGELOG.md in NeoVim\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eOf course this is only a simple example. The possibilities with FZF are endless.\nThere are countless ways in which you can use it to filter input and use that in\nanother command. We\u0026#x27;ll dive more into that later.\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"what-about-ripgrep\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#what-about-ripgrep\"\u003eWhat about ripgrep?\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAs it already says in the name, it is another \u003ccode\u003egrep\u003c/code\u003e program. Ripgrep is written\nin rust and one of its primary goals is to be the \u003cem\u003efastest\u003c/em\u003e \u003ccode\u003egrep\u003c/code\u003e of them all.\nIt performs amazing even in a larger code base.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:23.4375%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eRipgrep list files with FZF\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eRipgrep has many options to explore, there are way to many to list here.\nSome of the options I use most often with ripgrep are:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003e--files\u003c/code\u003e \u003c!-- --\u003eâ€”\u003c!-- --\u003e List files which ripgrep will search instead of searching them\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003e--hidden\u003c/code\u003e \u003c!-- --\u003eâ€”\u003c!-- --\u003e Show hidden (\u003ccode\u003e.file\u003c/code\u003e) files\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003e--no-ignore-vcs\u003c/code\u003e \u003c!-- --\u003eâ€”\u003c!-- --\u003e Show files ignored by your VCS\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003e--vimgrep\u003c/code\u003e \u003c!-- --\u003eâ€”\u003c!-- --\u003e Results are returned on a single line in vimgrep format\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"the-problems-they-solve\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#the-problems-they-solve\"\u003eThe problems they solve\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eBoth these tools can be combined in various scenario\u0026#x27;s that would have otherwise\ntaken multiple long commands to execute. This ranges from killing processes to\nmanaging plugins to being able to find (in) files.\u003c/p\u003e\u003cp\u003eThese actions are usually involved when I try to do something more complex:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003egoogling the right command\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003elook around for the right line in the output\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003erefine \u003ccode\u003egrep\u003c/code\u003e pattern\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eretrying the command\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAt this point you\u0026#x27;ll realize that you\u0026#x27;re not actually searching for something\nanymore. You find yourself looking for ways to perform your search instead :/\u003c/p\u003e\u003cp\u003eMy solution to \u003cstrike\u003enot being able\u003c/strike\u003e being too lazy to memorize these commands is to create\nsmall shell wrappers for them. I learn / read docs on a command to figure out how to\napply it for my use case(s). Then I write the wrapper based on the ideas I have about\nhow it should work.\u003c/p\u003e\u003cp\u003eWith that being said, let\u0026#x27;s dive right in with a common case:\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"killing-processes\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#killing-processes\"\u003eKilling processes\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eOne example is stopping an out of control process. First you have to find the\nprocess ID by issuing some command like \u003ccode\u003eps -ef | grep [PROCESS NAME]\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eWhich is then followed by a \u003ccode\u003ekill\u003c/code\u003e command with one of the process IDs you want\nto kill. The downsides to this are that I have to use two commands. Filter the\noutput before seeing it or knowing how it looks and issuing an extra command\nto actually stop the process.\u003c/p\u003e\u003cp\u003eTo make this easier, I wrote a small wrapper (first in \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/kp\" title=\"View kp zsh script\"\u003ezsh\u003c/a\u003e,\nlater migrated to \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/kp.fish\" title=\"View kp fish script\"\u003efish\u003c/a\u003e) called \u003ccode\u003ekp\u003c/code\u003e.\nIt lists processes using \u003ccode\u003eps -ef\u003c/code\u003e and pipes it to \u003ccode\u003efzf\u003c/code\u003e.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:23.4375%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eKilling processes using kp\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThis command opens an FZF window with your processes. FZF has an option to allow\nselecting multiple entries (\u003ccode\u003e-m flag\u003c/code\u003e). When \u003ckbd\u003eenter\u003c/kbd\u003e is pressed, both marked\n(light red \u003ccode\u003e\u0026gt;\u003c/code\u003e symbols) processes will be shut down. When changing your query,\nselected entries will stay selected. This is convenient for killing different\nprocesses in a single run.\u003c/p\u003e\u003cp\u003eAfter killing some processes, the command will rerun itself. I can use \u003ckbd\u003eescape\u003c/kbd\u003e to\nexit from this specific window.\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"installing-brew-plugins\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#installing-brew-plugins\"\u003eInstalling brew plugins\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAnother use case is to install, update or purge \u003ca href=\"https://github.com/Homebrew\" title=\"Visit Homebrew on GitHub\"\u003ebrew\u003c/a\u003e\nplugins from your system. When you are looking for a brew package, a common pattern\nis to use \u003ccode\u003ebrew search\u003c/code\u003e together with \u003ccode\u003egrep\u003c/code\u003e to find out if it exists.\u003c/p\u003e\u003cp\u003eAfter that you\u0026#x27;ll most likely run a command like: \u003ccode\u003ebrew install [PACKAGE]\u003c/code\u003e to install it.\nAnother pattern is to use the \u003ccode\u003ebrew leaves\u003c/code\u003e command to list installed packages which can\nbe updated or removed.\u003c/p\u003e\u003cp\u003eI created a small wrapper for each of these actions. One for installing,\nanother for updating and one for deleting brew packages:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003ebip\u003c/code\u003e \u003c!-- --\u003eâ€”\u003c!-- --\u003e \u003cstrong\u003eB\u003c/strong\u003e\u003cem\u003erew\u003c/em\u003e \u003cstrong\u003eI\u003c/strong\u003e\u003cem\u003enstall\u003c/em\u003e \u003cstrong\u003eP\u003c/strong\u003e\u003cem\u003elugin\u003c/em\u003e, install one or more plugins (\u003ca href=\"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bip\" title=\"View bip zsh script\"\u003ezsh\u003c/a\u003e, \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bip.fish\" title=\"View bip fish script\"\u003efish\u003c/a\u003e)\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003ebup\u003c/code\u003e \u003c!-- --\u003eâ€”\u003c!-- --\u003e \u003cstrong\u003eB\u003c/strong\u003e\u003cem\u003erew\u003c/em\u003e \u003cstrong\u003eU\u003c/strong\u003e\u003cem\u003epdate\u003c/em\u003e \u003cstrong\u003eP\u003c/strong\u003e\u003cem\u003elugin\u003c/em\u003e, update multiple installed plugins (\u003ca href=\"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bup\" title=\"View bup zsh script\"\u003ezsh\u003c/a\u003e, \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bup.fish\" title=\"View bup fish script\"\u003efish\u003c/a\u003e)\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003ebcp\u003c/code\u003e \u003c!-- --\u003eâ€”\u003c!-- --\u003e \u003cstrong\u003eB\u003c/strong\u003e\u003cem\u003erew\u003c/em\u003e \u003cstrong\u003eC\u003c/strong\u003e\u003cem\u003elean\u003c/em\u003e \u003cstrong\u003eP\u003c/strong\u003e\u003cem\u003elugin\u003c/em\u003e, delete multiple installed plugins (\u003ca href=\"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/bcp\" title=\"View bcp zsh script\"\u003ezsh\u003c/a\u003e, \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/bcp.fish\" title=\"View bcp fish script\"\u003efish\u003c/a\u003e)\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWhenever I have to do anything with brew, it is completely painless and it\nworks quite well for package discovery too.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:23.4375%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eBrew Install Plugin interface\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"finding-binaries\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#finding-binaries\"\u003eFinding binaries\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eOne mythical beast known to anyone who has ever worked in a terminal is the \u003ccode\u003e$PATH\u003c/code\u003e\nvariable. Often, a shell script will tell you to \u0026quot;Add me to your $PATH\u0026quot; so that the\nscript will become available in your shell. This makes sense but can leave you with\na messed up shell path or duplicate entries. It could cause all kinds of weirdness\nand slowness in your terminal.\u003c/p\u003e\u003cp\u003eMy solution to this is a simple path explorer called \u003ccode\u003efp\u003c/code\u003e (\u003ca href=\"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/fp\" title=\"View fp zsh script\"\u003ezsh\u003c/a\u003e, \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/e94b96b908479950186e42a3709511a0afe300e4/.config/fish/functions/fp.fish\" title=\"View fp fish script\"\u003efish\u003c/a\u003e).\nIt invokes FZF with a list of folders populated using \u003ccode\u003e$PATH\u003c/code\u003e.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:23.4375%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eDirectories present in $PATH\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eOf course there are more than 3 paths in my list but I cropped the gif for brevity here.\nWhen I press \u003ckbd\u003eenter\u003c/kbd\u003e on the \u003ccode\u003e/bin\u003c/code\u003e entry, I see a list of executables inside that folder.\nEither find what you\u0026#x27;re looking for or go back.\u003c/p\u003e\u003cp\u003eGoing back to the overview is as easy as pressing \u003ckbd\u003eescape\u003c/kbd\u003e. This will take you back to\nthe directory listing. Pressing \u003ckbd\u003eescape\u003c/kbd\u003e in the overview will exit the command completely.\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"checking-features-on-caniuse\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#checking-features-on-caniuse\"\u003eChecking features on caniuse.com\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAdditionally, I\u0026#x27;ve written a post before on how to \u003ca href=\"/blog/combining-caniuse-with-fzf\" title=\"Read the \u0026#x27;combine Caniuse with FZF post\u0026#x27;\"\u003ecombine Caniuse with FZF\u003c/a\u003e.\nIt allows me to quickly find out whether I should stay away from some Web API or not.\nthis small tool also allows me to query features that have been added or deprecated recently.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:23.4375%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eAn example of looking for features using cani\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThe \u003ccode\u003ecani\u003c/code\u003e command (\u003ca href=\"https://github.com/SidOfc/dotfiles/blob/d07fa3862ed065c2a5a7f1160ae98416bfe2e1ee/zsh/cani\" title=\"View cani zsh script\"\u003ezsh\u003c/a\u003e, \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/1e07bc882e64cc22783ac8ec2a01651503ecc7b3/.config/fish/functions/cani.fish\" title=\"View cani fish script\"\u003efish\u003c/a\u003e) itself uses another \u003ca href=\"https://github.com/SidOfc/dotfiles/blob/653c0331b3bd8a3b6fb5fbff0531f038e7eb5b12/bin/ciu\" title=\"View ciu ruby script\"\u003eruby script\u003c/a\u003e\n(\u003ccode\u003eciu\u003c/code\u003e) I wrote to actually provide the data and format it properly.\nThe data is fetched once then cached for a day.\nSo you\u0026#x27;ll have fresh data on a daily basis :)\u003c/p\u003e\u003cp\u003e\u003cem\u003eThis mixture of shell + ruby has since been \u003ca href=\"https://github.com/SidOfc/cani\" title=\"View SidOfc/cani on GitHub\"\u003eported\u003c/a\u003e to a \u003ca href=\"https://rubygems.org/gems/cani\" title=\"View cani gem on rubygems.org\"\u003eRuby Gem\u003c/a\u003e :)\u003c/em\u003e\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"vim\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#vim\"\u003eVim\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eSince I spend a lot of my time in Vim trying to find a file either by name,\nor by some code \u003cem\u003einside\u003c/em\u003e a certain file. Streamlining that process is very important.\nEvery context switch you have to make adds overhead and the possibility of losing\nfocus of what you are trying to find. Therefore it should be as mindless as possible,\ne.g: press a key, type query, press enter to go to matching file.\u003c/p\u003e\u003cp\u003eFinding files wasn\u0026#x27;t too much of an issue here. There is a long list of Vim plugins\nthat offer file searching using fuzzy matching or \u003ca href=\"https://en.wikipedia.org/wiki/Most_Recently_Used\" title=\"Visit Most Recently Used definition on wikipedia.org\"\u003eMRU\u003c/a\u003e algorithms. Two examples of this are \u003ca href=\"https://github.com/ctrlpvim/ctrlp.vim\" title=\"Visit ctrlpvim/ctrlp.vim on GitHub\"\u003eCtrlP\u003c/a\u003e and \u003ca href=\"https://github.com/wincent/command-t\" title=\"Visit wincent/command-t on github\"\u003eCommand-T\u003c/a\u003e.\nI used CtrlP which always managed to do the job. But after playing around with FZF\nin the terminal I wondered if it could be applied to Vim as well.\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"fzf\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#fzf\"\u003eFZF.vim\u003c/a\u003e\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://github.com/junegunn/fzf.vim\" title=\"Visit junegunn/fzf.vim on GitHub\"\u003eFZF\u003c/a\u003e has a small builtin Vim interface that already works, but it comes without\nany existing functionality. The author of FZF also wrote this plugin.\nIt is a small wrapper that provides common functionality. This includes listing files,\nbuffers, tags, git logs and much more!\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"fuzzy-searching-in-file-paths\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#fuzzy-searching-in-file-paths\"\u003eFuzzy searching in file paths\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eComing from CtrlP the first thing I needed was a replacement for fuzzy-finding files.\nThe solution was to use the \u003ccode\u003e:Files\u003c/code\u003e command provided by FZF.vim. This lists files\nusing your \u003ccode\u003e$FZF_DEFAULT_COMMAND\u003c/code\u003e environment variable. It opens the currently\nhighlighted file on \u003ckbd\u003eenter\u003c/kbd\u003e.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:68.0648236415634%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eFZF :Files demo\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eSince I was already so used to the \u003ckbd\u003ectrl\u003c/kbd\u003e+\u003ckbd\u003ep\u003c/kbd\u003e mapping from the CtrlP plugin,\nI mapped the \u003ccode\u003e:Files\u003c/code\u003e command to it: \u003ccode\u003ennoremap \u0026lt;C-p\u0026gt; :Files\u0026lt;Cr\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFZF will not use ripgrep by default so you\u0026#x27;ll have to modify \u003ccode\u003e$FZF_DEFAULT_COMMAND\u003c/code\u003e\nif you want FZF to use ripgrep. Of course this is exactly what I wanted!\nAfter some tweaking I ended up with the following command:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eFish syntax:\u003c/strong\u003e \u003ccode\u003eset -gx FZF_DEFAULT_COMMAND \u0026#x27;rg --files --no-ignore-vcs --hidden\u0026#x27;\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eBash / ZSH syntax:\u003c/strong\u003e \u003ccode\u003eexport FZF_DEFAULT_COMMAND=\u0026#x27;rg --files --no-ignore-vcs --hidden\u0026#x27;\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn my case it happens that I do want to edit or search for something in a file\nthat is ignored by my VCS or in a hidden file. The options ensure that all files\ninside the directory are listed (except those ignored in a \u003ccode\u003e~/.rgignore\u003c/code\u003e file).\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"finding-content-in-specific-files\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#finding-content-in-specific-files\"\u003eFinding content in specific files\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLast but not least I wanted to find files based on what was inside of a file.\nThis is useful to see where a class or function is used for example.\u003c/p\u003e\u003cfigure class=\"media_figure__1BF98\"\u003e\u003cdiv class=\"lazyload-wrapper \"\u003e\u003cdiv style=\"padding-bottom:68.0648236415634%\"\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption class=\"media_alt__xSx7S\"\u003eFZF :Rg demo\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThe name of this command is \u003ccode\u003e:Rg\u003c/code\u003e which already uses \u003ccode\u003eripgrep\u003c/code\u003e in the background! Done right?\nNope \u003c!-- --\u003eâ€”\u003c!-- --\u003e after playing around I noticed that while \u003ccode\u003e:Rg\u003c/code\u003e indeed searches the file\u0026#x27;s\n\u003cem\u003econtents\u003c/em\u003e, it also matches the \u003cem\u003efile name\u003c/em\u003e shown in the list like \u003ccode\u003e:Files\u003c/code\u003e does (exclusively).\u003c/p\u003e\u003cp\u003eIn my brain these concepts are completely isolated from each other:\u003c/p\u003e\u003cp\u003eWhen I need to find a specific \u003cem\u003efile\u003c/em\u003e I \u003cem\u003eknow\u003c/em\u003e that I\u0026#x27;m looking for a \u003cem\u003efilename\u003c/em\u003e in\nwhich case I do not want to search \u003cem\u003einside\u003c/em\u003e the file.\u003c/p\u003e\u003cp\u003eOn the other hand, when I need to find a specific area of known code or figure out\nin which files a certain class is used, I am most certainly never interested in matches from filenames.\u003c/p\u003e\u003cp\u003eTo achieve what I wanted, I had to override the default behavior.\nAn \u003ca href=\"https://github.com/junegunn/fzf.vim/issues/346\" title=\"Visit junegunn/fzf.vim issue #346\"\u003eissue\u003c/a\u003e was created for the\nexact same reason for the \u003ccode\u003e:Ag\u003c/code\u003e command. Based on \u003ca href=\"https://github.com/junegunn/fzf.vim/issues/346#issuecomment-288483704\" title=\"Visit junegunn/fzf.vim issue #346 issue comment\"\u003ethis comment\u003c/a\u003e\nI came up with the following setup to accomplish this:\u003c/p\u003e\u003cpre class=\"prism-code language-viml\" style=\"background-color:#2a2734;color:#9a86fd\"\u003e\u003cdiv class=\"token-line\" style=\"color:#9a86fd\"\u003e\u003cspan class=\"token plain\"\u003ecommand\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e!\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e-\u003c/span\u003e\u003cspan class=\"token plain\"\u003ebang \u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e-\u003c/span\u003e\u003cspan class=\"token plain\"\u003enargs\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e*\u003c/span\u003e\u003cspan class=\"token plain\"\u003e Rg\u003c/span\u003e\u003c/div\u003e\u003cdiv class=\"token-line\" style=\"color:#9a86fd\"\u003e\u003cspan class=\"token plain\"\u003e  \u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e\\\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token keyword\" style=\"color:#ffcc99\"\u003ecall\u003c/span\u003e\u003cspan class=\"token plain\"\u003e fzf\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e#\u003c/span\u003e\u003cspan class=\"token plain\"\u003evim\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e#\u003c/span\u003e\u003cspan class=\"token function\" style=\"color:#fa60c3\"\u003egrep\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e(\u003c/span\u003e\u003cspan class=\"token plain\"\u003e\u003c/span\u003e\u003c/div\u003e\u003cdiv class=\"token-line\" style=\"color:#9a86fd\"\u003e\u003cspan class=\"token plain\"\u003e  \u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e\\\u003c/span\u003e\u003cspan class=\"token plain\"\u003e   \u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;rg --column --line-number --hidden --ignore-case --no-heading --color=always \u0026#x27;\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\" style=\"color:#fa60c3\"\u003eshellescape\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e(\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"token keyword\" style=\"color:#ffcc99\"\u003eq\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e-\u003c/span\u003e\u003cspan class=\"token keyword\" style=\"color:#ffcc99\"\u003eargs\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e,\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token number\" style=\"color:#e09142\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e,\u003c/span\u003e\u003cspan class=\"token plain\"\u003e\u003c/span\u003e\u003c/div\u003e\u003cdiv class=\"token-line\" style=\"color:#9a86fd\"\u003e\u003cspan class=\"token plain\"\u003e  \u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e\\\u003c/span\u003e\u003cspan class=\"token plain\"\u003e   \u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"token plain\"\u003ebang\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"token number\" style=\"color:#e09142\"\u003e0\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e?\u003c/span\u003e\u003cspan class=\"token plain\"\u003e fzf\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e#\u003c/span\u003e\u003cspan class=\"token plain\"\u003evim\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e#\u003c/span\u003e\u003cspan class=\"token function\" style=\"color:#fa60c3\"\u003ewith_preview\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e{\u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;options\u0026#x27;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e:\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;--delimiter : --nth 4..\u0026#x27;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e,\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;up:60%\u0026#x27;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e)\u003c/span\u003e\u003cspan class=\"token plain\"\u003e\u003c/span\u003e\u003c/div\u003e\u003cdiv class=\"token-line\" style=\"color:#9a86fd\"\u003e\u003cspan class=\"token plain\"\u003e  \u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e\\\u003c/span\u003e\u003cspan class=\"token plain\"\u003e           \u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e:\u003c/span\u003e\u003cspan class=\"token plain\"\u003e fzf\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e#\u003c/span\u003e\u003cspan class=\"token plain\"\u003evim\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e#\u003c/span\u003e\u003cspan class=\"token function\" style=\"color:#fa60c3\"\u003ewith_preview\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e{\u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;options\u0026#x27;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e:\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;--delimiter : --nth 4..\u0026#x27;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e,\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;right:50%:hidden\u0026#x27;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e,\u003c/span\u003e\u003cspan class=\"token plain\"\u003e \u003c/span\u003e\u003cspan class=\"token string\" style=\"color:#ffcc99\"\u003e\u0026#x27;?\u0026#x27;\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e,\u003c/span\u003e\u003cspan class=\"token plain\"\u003e\u003c/span\u003e\u003c/div\u003e\u003cdiv class=\"token-line\" style=\"color:#9a86fd\"\u003e\u003cspan class=\"token plain\"\u003e  \u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e\\\u003c/span\u003e\u003cspan class=\"token plain\"\u003e   \u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"token plain\"\u003ebang\u003c/span\u003e\u003cspan class=\"token operator\" style=\"color:#e09142\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"token number\" style=\"color:#e09142\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\" style=\"color:#6c6783\"\u003e)\u003c/span\u003e\u003c/div\u003e\u003c/pre\u003e\u003cp\u003eThis one I mapped to \u003ckbd\u003ectrl\u003c/kbd\u003e+\u003ckbd\u003eg\u003c/kbd\u003e, right next to \u003ckbd\u003ectrl\u003c/kbd\u003e+\u003ckbd\u003ef\u003c/kbd\u003e\nfor the \u003ccode\u003e:Files\u003c/code\u003e command: \u003ccode\u003ennoremap \u0026lt;C-g\u0026gt; :Rg\u0026lt;Cr\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThe nice thing about this command is that you can select multiple files.\nWhen selecting multiple files, pressing \u003ckbd\u003eenter\u003c/kbd\u003e will load the files in a\nquickfix list for batch editing using \u003ccode\u003ecdo\u003c/code\u003e for example.\u003c/p\u003e\u003ch2 class=\"heading_container__2UElk\"\u003e\u003ca class=\"heading_anchor__PWj4r\" id=\"conclusion\"\u003e\u003c/a\u003e\u003ca class=\"heading_link__1aoFY\" href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAs I mentioned at the start of my post, these tools have become a \u003cstrong\u003evital\u003c/strong\u003e\npart of my workflow. I use them while barely noticing their presence and they\ntake a lot of complexity away from the task at hand. This allows me to focus\non what matters instead of finding out how to do something which should be trivial.\u003c/p\u003e\u003cp\u003eWhether it be killing services / processes, installing brew packages,\nfinding a glitch in my path or a feature set in caniuse, I can do it in fewer\nkeystrokes with more fine-grained control. I even use FZF as a standalone\nfilter sometimes when I have to find something in line-based command output,\nskipping (rip)grep all together :)\u003c/p\u003e\u003cp\u003eHopefully you are also able to reduce some of the strain in your workflow with\nFZF using some of the tips above. If you are using FZF in another way, leave a\ncomment! I\u0026#x27;d love to hear about it and learn what others are doing with these\ntwo fantastic tools.\u003c/p\u003e\u003cp\u003eHappy fuzzy finding :)\u003c/p\u003e\u003cp\u003eðŸ‘‹\u003c/p\u003e","scope":{"title":"How FZF and ripgrep improved my workflow","description":"In my never ending quest for simplicity I recently discovered FZF and ripgrep. Two command-line tools that have the potential to make every dag programming tasks easier. In this post I will explain how I use these tools to do things in a matter of keystrokes rather than having to re-google that command you keep forgetting \u003cstrong\u003eevery. single. time.\u003c/strong\u003e.","published":"2018-06-24T13:33:37Z","updated":"2019-07-10T21:10:00Z"}},"slug":"how-fzf-and-ripgrep-improved-my-workflow"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"how-fzf-and-ripgrep-improved-my-workflow"},"buildId":"xBGBAFFpZVoAjE30tzHzN","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ff94e68042added27a93.js"></script><script src="/_next/static/chunks/main-25074903459b76ecf3d7.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.29f9e2f3d4a33bafbaa5.js" async=""></script><script src="/_next/static/chunks/commons.8605d6b0be09876fb5ed.js" async=""></script><script src="/_next/static/chunks/62e1beb3a59d93297dd568d6addecfcbe54736d1.aa64992a2bd5287741c5.js" async=""></script><script src="/_next/static/chunks/pages/_app-3951d5f435ad98bbfb01.js" async=""></script><script src="/_next/static/chunks/89c7192737f5dae381690d2d2c3016603346826c.3fe8d6de12c9023523b3.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-9b59dd61cc9c9ff95369.js" async=""></script><script src="/_next/static/xBGBAFFpZVoAjE30tzHzN/_buildManifest.js" async=""></script><script src="/_next/static/xBGBAFFpZVoAjE30tzHzN/_ssgManifest.js" async=""></script></body></html>