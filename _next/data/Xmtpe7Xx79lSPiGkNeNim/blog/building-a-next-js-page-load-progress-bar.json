{"pageProps":{"title":"Building a Next.js page load progress bar","description":"I've seen a fair few tutorials on building a page load progress bar for Next.js applications but most of them use the external library NProgress. While NProgress is a very nice general purpose library we can also build our own 'cheap' progress bar without using any library!","published":"2021-04-18T19:00:00Z","readTimeInMinutes":7,"source":{"compiledSource":"var u=Object.defineProperty,c=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var a=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var l=(e,t,n)=>t in e?u(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,o=(e,t)=>{for(var n in t||(t={}))a.call(t,n)&&l(e,n,t[n]);if(r)for(var n of r(t))s.call(t,n)&&l(e,n,t[n]);return e},p=(e,t)=>c(e,h(t));var d=(e,t)=>{var n={};for(var i in e)a.call(e,i)&&t.indexOf(i)<0&&(n[i]=e[i]);if(e!=null&&r)for(var i of r(e))t.indexOf(i)<0&&s.call(e,i)&&(n[i]=e[i]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var i=n,{components:e}=i,t=d(i,[\"components\"]);return mdx(MDXLayout,p(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`In this post I'm going to cover why you would want to add a page load progress bar\nto your Next.js application as well as how you could go about implementing it\nwithout using any external libraries. Let's dive right in!`),mdx(\"h1\",null,\"Why add a page load progress bar\"),mdx(\"p\",null,`If you've ever visited a slow website and clicked a navigation link,\nit may have felt like the page was not responding. This might have given\nyou a certain feeling of frustration perhaps, even provoking you to click\none or multiple times.`),mdx(\"p\",null,`What really happened in the background was that the server got your request\nand started preparing this page on the back-end but it just took a while to\ncomplete. Since you didn't get any kind of indication that something was happening\nyou just decided to mash that button again.`),mdx(\"p\",null,`In the worst case the webserver actually starts processing this second\nclick for the exact same page as well, needlessly increasing server load.\nThis implies two negative side effects. First, the webserver processed\na request twice, and second, the user has become more impatient than\nthey already were due to poor loading experience.`),mdx(\"p\",null,`Of course the button could just be disabled on click, while this does\nprevent the user from rage clicking it doesn't improve their browsing\nexperience on your website at all. This is why it may help to show\nyour users a page load progress bar.`),mdx(\"h1\",null,\"Implementing the page load progress bar\"),mdx(\"p\",null,`For this part I will be using Next.js' built-in support for CSS modules\nand the provided `,mdx(\"inlineCode\",{parentName:\"p\"},\"useRouter\"),` hook so that we can hook into router events\nprovided by Next.js. The choice of CSS library is completely yours, you\ncould opt to use styled-jsx or styled-components if you'd like.\nFurthermore this will be a self-contained component, when it's done you\ncan just drop `,mdx(\"inlineCode\",{parentName:\"p\"},\"<Progress />\"),` into your Next.js page layout file and\neverything should just work.`),mdx(\"h2\",null,\"Setting up the component\"),mdx(\"p\",null,`To start off, let's first create the files we need for this component.\nI'll assume you have some folder such as `,mdx(\"inlineCode\",{parentName:\"p\"},\"components/\"),` which holds all\nyour React components. Add a `,mdx(\"inlineCode\",{parentName:\"p\"},\"progress/\"),` folder inside this folder and\nadd an `,mdx(\"inlineCode\",{parentName:\"p\"},\"index.js\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"progress.module.css\"),\" file to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"progress/\"),` folder.\nYour directory structure should look like this:`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-plain\"}),`. (root)\n|- components\n|--|- progress\n|--|--|- index.js\n|--|--|- progress.module.css\n`)),mdx(\"p\",null,\"With these files set up we can now open \",mdx(\"inlineCode\",{parentName:\"p\"},\"progress/index.js\"),` to start\nworking on our component. We'll need to use the `,mdx(\"inlineCode\",{parentName:\"p\"},\"useRouter\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"useEffect\"),` hooks\nto bind listeners to navigation events and we'll need to use `,mdx(\"inlineCode\",{parentName:\"p\"},\"useState\"),`\nto keep track of the progress:`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-jsx\"}),`import {useEffect, useState} from 'react';\nimport {useRouter} from 'next/router';\nimport styles from './progress.module.css';\n\nexport default function Progress() {\n    const router = useRouter();\n    const [progress, setProgress] = useState(0);\n\n    return (\n        <div className={styles.progress}>\n            <div\n                className={styles.indicator}\n                style={{\n                    width: \\`\\${progress}%\\`,\n                    opacity: progress > 0 && progress < 100 ? 1 : 0,\n                }}\n            />\n        </div>\n    )\n}\n`)),mdx(\"p\",null,`Of course this doesn't do much yet but at least we now have a component\nthat we can `,mdx(\"inlineCode\",{parentName:\"p\"},\"import\"),` in our layout or header file. We did set up\na little bit of dynamic styling in the `,mdx(\"inlineCode\",{parentName:\"p\"},\".indicator\"),` element so set\nthe `,mdx(\"inlineCode\",{parentName:\"p\"},\"width\"),\" equal to \",mdx(\"inlineCode\",{parentName:\"p\"},\"${progress}%\"),\" and to set \",mdx(\"inlineCode\",{parentName:\"p\"},\"opacity\"),\" to \",mdx(\"inlineCode\",{parentName:\"p\"},\"1\"),` whenever\nit is active (`,mdx(\"inlineCode\",{parentName:\"p\"},\"progress\"),\" not \",mdx(\"inlineCode\",{parentName:\"p\"},\"0\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"100\"),`). You can go ahead\nand import and render it on your page. Nothing will show up yet but we're\ngoing to fix that now by adding some CSS.`),mdx(\"h2\",null,\"Styling the component\"),mdx(\"p\",null,\"Open \",mdx(\"inlineCode\",{parentName:\"p\"},\"progress/progress.module.css\"),\" and add the following:\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-css\"}),`.progress {\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 999999;\n  height: 0.15rem;\n  width: 100%;\n}\n\n.indicator {\n  background-color: yellow;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  width: 0;\n  transition: all 0.1s linear, opacity 0.3s linear 0.2s;\n}\n`)),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\".progress\"),` class is the outer container which will create a fixed\nspace at the top of the page which `,mdx(\"inlineCode\",{parentName:\"p\"},\".indicator\"),` will fill up. The\n`,mdx(\"inlineCode\",{parentName:\"p\"},\".indicator\"),\" has some transition effects to animate both \",mdx(\"inlineCode\",{parentName:\"p\"},\"width\"),` and\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"opacity\"),` so the bar fades in and out nicely and width transitions\nalso look smooth. If we now go ahead and set the progress to something\nother than `,mdx(\"inlineCode\",{parentName:\"p\"},\"0\"),` initially, we should see a yellow bar at the top,\nlet's set it to `,mdx(\"inlineCode\",{parentName:\"p\"},\"40\"),\":\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-jsx\"}),`const [progress, setProgress] = useState(40);\n`)),mdx(\"p\",null,`Now reload the page and you should see a progress bar already at 40% progress.\nThis is the time you'll want to do some additional styling if you don't like\nhow it looks. Also don't forget to set the `,mdx(\"inlineCode\",{parentName:\"p\"},\"useState\"),\" default back to \",mdx(\"inlineCode\",{parentName:\"p\"},\"0\"),`\nwhen you're done :)`),mdx(\"h2\",null,\"Binding the events\"),mdx(\"p\",null,`All we have to do now is to hook up to Next.js' router events\nand make this bar move on its own whenever a navigation event occurs. To\ndo this we'll add a `,mdx(\"inlineCode\",{parentName:\"p\"},\"useEffect\"),` hook without any dependencies so that\nit works like `,mdx(\"a\",o({parentName:\"p\"},{href:\"https://reactjs.org/docs/react-component.html#componentdidmount\"}),mdx(\"inlineCode\",{parentName:\"a\"},\"componentDidMount\")),`\n/ `,mdx(\"a\",o({parentName:\"p\"},{href:\"https://reactjs.org/docs/react-component.html#componentwillunmount\"}),mdx(\"inlineCode\",{parentName:\"a\"},\"componentWillUnmount\")),`\nlifecycle methods.`),mdx(\"p\",null,`We do this since we want\nto make sure these listeners are only bound once, and should an unmount\noccur we also want to make sure the old listeners are cleaned up\nbefore any new ones are attached. This allows us to set up the listeners once,\nand if an unmount occurs this also allows us to clean up the listeners:`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-jsx\"}),`useEffect(() => {\n    let timer;\n\n    function start() {\n        setProgress(1);\n        increment();\n    }\n\n    function increment() {\n        const timeout = Math.round(Math.random() * 300);\n\n        setProgress((progress) => {\n            const percent = Math.round(Math.random() * 10);\n            const next = Math.min(progress + percent, 80);\n\n            if (next < 80) {\n                timer = setTimeout(increment, timeout);\n                return next;\n            }\n\n            return 80;\n        });\n    }\n\n    function complete() {\n        clearTimeout(timer);\n        setProgress(100);\n    }\n\n    router.events.on('routeChangeStart', start);\n    router.events.on('routeChangeComplete', complete);\n    router.events.on('routeChangeError', complete);\n\n    return () => {\n        clearTimeout(timer);\n        router.events.off('routeChangeStart');\n        router.events.off('routeChangeComplete');\n        router.events.off('routeChangeError');\n    };\n}, []);\n`)),mdx(\"p\",null,\"With all the parts set up we can now go over the \",mdx(\"inlineCode\",{parentName:\"p\"},\"start\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"increment\"),` and\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"complete\"),\" functions. The \",mdx(\"inlineCode\",{parentName:\"p\"},\"start\"),` function kicks off the process on\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"routeChangeStart\"),\". It calls \",mdx(\"inlineCode\",{parentName:\"p\"},\"setProgress(1)\"),` which makes the progress bar\nvisible after a 0.2s delay defined in the CSS `,mdx(\"inlineCode\",{parentName:\"p\"},\"opacity\"),` transition.\nAfterwards, it also calls `,mdx(\"inlineCode\",{parentName:\"p\"},\"increment()\"),` which will repeatedly call itself\nusing `,mdx(\"inlineCode\",{parentName:\"p\"},\"setTimeout\"),\" until a certain threshold has been reached (\",mdx(\"inlineCode\",{parentName:\"p\"},\"80\"),` in this case).\nThis will move the progress bar at random intervals with random percentages added.`),mdx(\"p\",null,\"Finally the \",mdx(\"inlineCode\",{parentName:\"p\"},\"complete\"),\" function will be called either on \",mdx(\"inlineCode\",{parentName:\"p\"},\"routeChangeComplete\"),`\nor `,mdx(\"inlineCode\",{parentName:\"p\"},\"routeChangeError\"),\" which will clear any remaining timeout set by \",mdx(\"inlineCode\",{parentName:\"p\"},\"increment\"),`\nand force the bar to `,mdx(\"inlineCode\",{parentName:\"p\"},\"100\"),\" progress causing it to fill up and fade out.\"),mdx(\"p\",null,\"We can safely leave \",mdx(\"inlineCode\",{parentName:\"p\"},\"progress\"),\" at \",mdx(\"inlineCode\",{parentName:\"p\"},\"100\"),` here. There is no need to reset it\nto `,mdx(\"inlineCode\",{parentName:\"p\"},\"0\"),\" because in our component logic we set \",mdx(\"inlineCode\",{parentName:\"p\"},\"opacity\"),\" to \",mdx(\"inlineCode\",{parentName:\"p\"},\"0\"),` when the bar\nis either at `,mdx(\"inlineCode\",{parentName:\"p\"},\"0\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"100\"),` progress. Additionally when new navigation events\noccur the `,mdx(\"inlineCode\",{parentName:\"p\"},\"start\"),\" function is called which always sets it to \",mdx(\"inlineCode\",{parentName:\"p\"},\"1\"),\".\"),mdx(\"h1\",null,\"Everything together\"),mdx(\"p\",null,\"Finally, you'll end up with this component:\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-jsx\"}),`import {useEffect, useState} from 'react';\nimport {useRouter} from 'next/router';\nimport styles from './progress.module.css';\n\nexport default function Progress() {\n    const router = useRouter();\n    const [progress, setProgress] = useState(0);\n\n    useEffect(() => {\n        let timer;\n\n        function start() {\n            setProgress(1);\n            increment();\n        }\n\n        function increment() {\n            const timeout = Math.round(Math.random() * 300);\n\n            setProgress((progress) => {\n                const percent = Math.round(Math.random() * 10);\n                const next = Math.min(progress + percent, 80);\n\n                if (next < 80) {\n                    timer = setTimeout(increment, timeout);\n                    return next;\n                }\n\n                return 80;\n            });\n        }\n\n        function complete() {\n            clearTimeout(timer);\n            setProgress(100);\n        }\n\n        router.events.on('routeChangeStart', start);\n        router.events.on('routeChangeComplete', complete);\n        router.events.on('routeChangeError', complete);\n\n        return () => {\n            clearTimeout(timer);\n            router.events.off('routeChangeStart');\n            router.events.off('routeChangeComplete');\n            router.events.off('routeChangeError');\n        };\n    }, []);\n\n    return (\n        <div className={styles.progress}>\n            <div\n                className={styles.indicator}\n                style={{\n                    width: \\`\\${progress}%\\`,\n                    opacity: progress > 0 && progress < 100 ? 1 : 0,\n                }}\n            />\n        </div>\n    );\n}\n`)),mdx(\"p\",null,\"While it isn't as fancy as something like \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://github.com/rstacruz/nprogress\"}),\"NProgress\"),`,\nwhich also shows a loading spinner, it doesn't require any library and it is\nalso less JS and CSS. Adding an endless spinner here also wouldn't be too\ndifficult if you really wanted to but this is something I'll leave\nas an exercise for the reader :)`),mdx(\"p\",null,\"If you've got any questions, feel free to hit me up on Twitter \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://twitter.com/scbydoooo\"}),\"@scbydoooo\"),\".\"),mdx(\"p\",null,\"Until next time!\"),mdx(\"p\",null,\"\\u{1F44B}\"))}MDXContent.isMDXComponent=!0;\n","scope":{"title":"Building a Next.js page load progress bar","description":"I've seen a fair few tutorials on building a page load progress bar for Next.js applications but most of them use the external library NProgress. While NProgress is a very nice general purpose library we can also build our own 'cheap' progress bar without using any library!","published":"2021-04-18T19:00:00Z"}},"slug":"building-a-next-js-page-load-progress-bar"},"__N_SSG":true}