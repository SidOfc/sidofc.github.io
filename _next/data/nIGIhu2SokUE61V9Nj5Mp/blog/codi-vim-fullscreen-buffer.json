{"pageProps":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the <code>Codi</code> command and improving the buffer name(s) as seen in <code>:ls</code>.","published":"2018-08-27T07:55:24Z","readTimeInMinutes":5,"source":{"compiledSource":"var l=Object.defineProperty,c=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var h=(e,t,i)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,n=(e,t)=>{for(var i in t||(t={}))s.call(t,i)&&h(e,i,t[i]);if(o)for(var i of o(t))r.call(t,i)&&h(e,i,t[i]);return e},p=(e,t)=>c(e,m(t));var d=(e,t)=>{var i={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(i[a]=e[a]);if(e!=null&&o)for(var a of o(e))t.indexOf(a)<0&&r.call(e,a)&&(i[a]=e[a]);return i};const makeShortcode=e=>function(i){return console.warn(\"Component \"+e+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",n({},i))},Media=makeShortcode(\"Media\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var a=i,{components:e}=a,t=d(a,[\"components\"]);return mdx(MDXLayout,p(n(n({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(Media,{src:\"/media/posts/codi-banner.png\",alt:\"A Codi.vim fullscreen buffer\",width:\"1672\",height:\"972\",className:\"wide\",mdxType:\"Media\"}),mdx(\"p\",null,\"Recently I discovered \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://github.com/metakirby5/codi.vim\",title:\"Visit metakirby5/codi.vim on GitHub\"}),\"codi.vim\"),\" on \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://vimawesome.com/?q=cat%3Aother\",title:\"Visit vimawesome.com 'Other' category plugin\"}),\"vimawesome.com\"),`.\nIt sells itself as an \"interactive scratchpad for hackers\".\nAfter playing around with it for 5 minutes I was completely sold.`),mdx(\"p\",null,`I pair program on a weekly basis using various different languages.\nI used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.\nMaking a typo in the middle of a `,mdx(\"inlineCode\",{parentName:\"p\"},\"do ... end\"),\" block in Ruby is quite costly:\"),mdx(Media,{src:\"/media/posts/pry-multiline-typo\",alt:\"Multiline expression typo in Pry\",width:\"1033\",height:\"250\",mdxType:\"Media\"}),mdx(\"p\",null,`Another thing to note here is that code and results are printed sequentially.\nThis means that any code you write goes off-screen at least twice as fast because the result is printed below it.`),mdx(\"p\",null,`In case of errors and stack traces it can become a lot worse as well.\nCodi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:`),mdx(Media,{src:\"/media/posts/ruby-demo\",alt:\"Demo of Ruby in Codi.vim\",width:\"1033\",height:\"141\",mdxType:\"Media\"}),mdx(\"p\",null,\"This feature, and the fact that I can toggle this buffer for \",mdx(\"em\",{parentName:\"p\"},\"multiple programming languages\"),` using a single mapping blew my mind but as with anything,\nit requires some more battle testing to see if it works in common scenario's.`),mdx(\"h2\",null,\"Battle testing\"),mdx(\"p\",null,\"This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:\"),mdx(Media,{src:\"/media/posts/split-behavior\",alt:\"Default split behavior\",width:\"1033\",height:\"496\",mdxType:\"Media\"}),mdx(\"p\",null,\"At this point I started experimenting with a small \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e\",title:\"Visit codi.vim snippet github gist\"}),\"vimscript snippet\"),` in my .vimrc.\nExcluding comments and blanks it is 10 LoC.\nIt wraps the default `,mdx(\"inlineCode\",{parentName:\"p\"},\"Codi\"),\" command in a function which creates an empty buffer in a new tab with the right filetype set before finally running \",mdx(\"inlineCode\",{parentName:\"p\"},\"Codi\"),` itself.\nThis creates the fullscreen split that I wanted:`),mdx(Media,{src:\"/media/posts/wrapped-split-behavior\",alt:\"Enhanced split behavior\",width:\"1033\",height:\"496\",mdxType:\"Media\"}),mdx(\"h2\",null,\"Problem solved, or maybe not?\"),mdx(\"p\",null,`All good so far, but upon closing the buffer, the contents of the buffer are deleted.\nWhile automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.`),mdx(\"p\",null,\"This required a \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62\",title:\"Visit second codi.vim snippet github gist\"}),\"second iteration\"),` of the original vimscript snippet.\nThis time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.\nAfter hiding the buffer, its `,mdx(\"inlineCode\",{parentName:\"p\"},\"tabpagenr()\"),\" is stored in a dictionary keyed by the filetype of the buffer.\"),mdx(\"p\",null,\"Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):\"),mdx(Media,{src:\"/media/posts/wrapped-split-behavior-2\",alt:\"Enhanced split behavior version 2\",width:\"1033\",height:\"496\",mdxType:\"Media\"}),mdx(\"p\",null,\"And there we go! Aside from the fact that the buffer now remains, the name is also \",mdx(\"inlineCode\",{parentName:\"p\"},\"scratch::ruby\"),`.\nThis is a bit more descriptive than having just `,mdx(\"inlineCode\",{parentName:\"p\"},\"[Scratch]\"),\" in \",mdx(\"inlineCode\",{parentName:\"p\"},\":ls\"),\" output when multiple codi buffers of a different filetype are active.\"),mdx(\"h2\",null,\"Let's wrap it in an issue\"),mdx(\"p\",null,`It was a fun experience tweaking this plugin to my liking.\nI thought this feature would be so awesome that I even proposed it in an `,mdx(\"a\",n({parentName:\"p\"},{href:\"https://github.com/metakirby5/codi.vim/issues/94\",title:\"View metakirby5/codi.vim issue #94\"}),\"issue\"),`.\nUnfortunately it didn't make it since it was too workflow specific.`),mdx(\"p\",null,\"As you may have been able to see in the issue though, the code in that snippet is \",mdx(\"em\",{parentName:\"p\"},\"slighty\"),` different from the example gist linked in this post.\nThe main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:`),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-viml\"}),`\" since it is fullscreen, I'd like a 50/50 split\nlet g:codi#width = winwidth(winnr()) / 2\n`)),mdx(\"p\",null,`The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.\nSo I went ahead and `,mdx(\"a\",n({parentName:\"p\"},{href:\"https://github.com/metakirby5/codi.vim/pull/95\",title:\"View metakirby5/codi.vim pull request #95\"}),\"wrote a PR\"),` for that instead, this is why you see\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"let g:codi#width = 50.0\"),\" in the gists :)\"),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,`All in all it was a great experience discovering this plugin.\nIt is like one of those rare cases with a song where after a few seconds `,mdx(\"strong\",{parentName:\"p\"},\"you just know\"),\" \",mdx(\"em\",{parentName:\"p\"},'\"this song is awesome\"'),`.\nI believe I'll be using it for a long time to come for quickly testing and showing some code.`),mdx(\"p\",null,`This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.\nSomething which I wanted to do for a long time but couldn't really find the right project to contribute to.\nI want to thank `,mdx(\"a\",n({parentName:\"p\"},{href:\"https://medium.com/@metakirby5\",title:\"View @metakirby5 on Medium\"}),\"Ethan Chan\"),\" for his awesome plugin and for being a kind and friendly maintainer!\"),mdx(\"p\",null,`That's it! If you want a fullscreen workflow with codi.vim, you have it.\nIf you want to persist the code in the buffer, you have it.\nIf you have a great idea, comment on this post!`),mdx(\"p\",null,\"Until next time.\"),mdx(\"p\",null,\"\\u{1F44B}\"))}MDXContent.isMDXComponent=!0;\n","scope":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the <code>Codi</code> command and improving the buffer name(s) as seen in <code>:ls</code>.","published":"2018-08-27T07:55:24Z"}},"slug":"codi-vim-fullscreen-buffer"},"__N_SSG":true}