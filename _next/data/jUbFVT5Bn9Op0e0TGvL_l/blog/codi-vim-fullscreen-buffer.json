{"pageProps":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the <code>Codi</code> command and improving the buffer name(s) as seen in <code>:ls</code>.","published":"2018-08-27T07:55:24Z","readTimeInMinutes":5,"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      a: \"a\",\n      code: \"code\",\n      em: \"em\",\n      h2: \"h2\",\n      pre: \"pre\",\n      strong: \"strong\"\n    }, _provideComponents(), props.components), {Media} = _components;\n    if (!Media) _missingMdxReference(\"Media\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsx(Media, {\n        src: \"/media/posts/codi-banner.png\",\n        alt: \"A Codi.vim fullscreen buffer\",\n        width: \"1672\",\n        height: \"972\",\n        className: \"wide\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Recently I discovered \", _jsx(_components.a, {\n          href: \"https://github.com/metakirby5/codi.vim\",\n          title: \"Visit metakirby5/codi.vim on GitHub\",\n          children: \"codi.vim\"\n        }), \" on \", _jsx(_components.a, {\n          href: \"https://vimawesome.com/?q=cat%3Aother\",\n          title: \"Visit vimawesome.com 'Other' category plugin\",\n          children: \"vimawesome.com\"\n        }), \".\\nIt sells itself as an \\\"interactive scratchpad for hackers\\\".\\nAfter playing around with it for 5 minutes I was completely sold.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"I pair program on a weekly basis using various different languages.\\nI used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.\\nMaking a typo in the middle of a \", _jsx(_components.code, {\n          children: \"do ... end\"\n        }), \" block in Ruby is quite costly:\"]\n      }), \"\\n\", _jsx(Media, {\n        src: \"/media/posts/pry-multiline-typo\",\n        alt: \"Multiline expression typo in Pry\",\n        width: \"1033\",\n        height: \"250\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Another thing to note here is that code and results are printed sequentially.\\nThis means that any code you write goes off-screen at least twice as fast because the result is printed below it.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In case of errors and stack traces it can become a lot worse as well.\\nCodi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:\"\n      }), \"\\n\", _jsx(Media, {\n        src: \"/media/posts/ruby-demo\",\n        alt: \"Demo of Ruby in Codi.vim\",\n        width: \"1033\",\n        height: \"141\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This feature, and the fact that I can toggle this buffer for \", _jsx(_components.em, {\n          children: \"multiple programming languages\"\n        }), \" using a single mapping blew my mind but as with anything,\\nit requires some more battle testing to see if it works in common scenario's.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Battle testing\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:\"\n      }), \"\\n\", _jsx(Media, {\n        src: \"/media/posts/split-behavior\",\n        alt: \"Default split behavior\",\n        width: \"1033\",\n        height: \"496\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"At this point I started experimenting with a small \", _jsx(_components.a, {\n          href: \"https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e\",\n          title: \"Visit codi.vim snippet github gist\",\n          children: \"vimscript snippet\"\n        }), \" in my .vimrc.\\nExcluding comments and blanks it is 10 LoC.\\nIt wraps the default \", _jsx(_components.code, {\n          children: \"Codi\"\n        }), \" command in a function which creates an empty buffer in a new tab with the right filetype set before finally running \", _jsx(_components.code, {\n          children: \"Codi\"\n        }), \" itself.\\nThis creates the fullscreen split that I wanted:\"]\n      }), \"\\n\", _jsx(Media, {\n        src: \"/media/posts/wrapped-split-behavior\",\n        alt: \"Enhanced split behavior\",\n        width: \"1033\",\n        height: \"496\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Problem solved, or maybe not?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"All good so far, but upon closing the buffer, the contents of the buffer are deleted.\\nWhile automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This required a \", _jsx(_components.a, {\n          href: \"https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62\",\n          title: \"Visit second codi.vim snippet github gist\",\n          children: \"second iteration\"\n        }), \" of the original vimscript snippet.\\nThis time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.\\nAfter hiding the buffer, its \", _jsx(_components.code, {\n          children: \"tabpagenr()\"\n        }), \" is stored in a dictionary keyed by the filetype of the buffer.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):\"\n      }), \"\\n\", _jsx(Media, {\n        src: \"/media/posts/wrapped-split-behavior-2\",\n        alt: \"Enhanced split behavior version 2\",\n        width: \"1033\",\n        height: \"496\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"And there we go! Aside from the fact that the buffer now remains, the name is also \", _jsx(_components.code, {\n          children: \"scratch::ruby\"\n        }), \".\\nThis is a bit more descriptive than having just \", _jsx(_components.code, {\n          children: \"[Scratch]\"\n        }), \" in \", _jsx(_components.code, {\n          children: \":ls\"\n        }), \" output when multiple codi buffers of a different filetype are active.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Let's wrap it in an issue\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"It was a fun experience tweaking this plugin to my liking.\\nI thought this feature would be so awesome that I even proposed it in an \", _jsx(_components.a, {\n          href: \"https://github.com/metakirby5/codi.vim/issues/94\",\n          title: \"View metakirby5/codi.vim issue #94\",\n          children: \"issue\"\n        }), \".\\nUnfortunately it didn't make it since it was too workflow specific.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"As you may have been able to see in the issue though, the code in that snippet is \", _jsx(_components.em, {\n          children: \"slighty\"\n        }), \" different from the example gist linked in this post.\\nThe main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-vim\",\n          children: \"\\\" since it is fullscreen, I'd like a 50/50 split\\nlet g:codi#width = winwidth(winnr()) / 2\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.\\nSo I went ahead and \", _jsx(_components.a, {\n          href: \"https://github.com/metakirby5/codi.vim/pull/95\",\n          title: \"View metakirby5/codi.vim pull request #95\",\n          children: \"wrote a PR\"\n        }), \" for that instead, this is why you see\\n\", _jsx(_components.code, {\n          children: \"let g:codi#width = 50.0\"\n        }), \" in the gists :)\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Conclusion\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"All in all it was a great experience discovering this plugin.\\nIt is like one of those rare cases with a song where after a few seconds \", _jsx(_components.strong, {\n          children: \"you just know\"\n        }), \" \", _jsx(_components.em, {\n          children: \"\\\"this song is awesome\\\"\"\n        }), \".\\nI believe I'll be using it for a long time to come for quickly testing and showing some code.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.\\nSomething which I wanted to do for a long time but couldn't really find the right project to contribute to.\\nI want to thank \", _jsx(_components.a, {\n          href: \"https://medium.com/@metakirby5\",\n          title: \"View @metakirby5 on Medium\",\n          children: \"Ethan Chan\"\n        }), \" for his awesome plugin and for being a kind and friendly maintainer!\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"That's it! If you want a fullscreen workflow with codi.vim, you have it.\\nIf you want to persist the code in the buffer, you have it.\\nIf you have a great idea, comment on this post!\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Until next time.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"ðŸ‘‹\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the <code>Codi</code> command and improving the buffer name(s) as seen in <code>:ls</code>.","published":"2018-08-27T07:55:24Z"}},"slug":"codi-vim-fullscreen-buffer"},"__N_SSG":true}