{"pageProps":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the <code>Codi</code> command and improving the buffer name(s) as seen in <code>:ls</code>.","published":"2018-08-27T07:55:24Z","readTimeInMinutes":5,"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Media, {\n    src: \"/media/posts/codi-banner.png\",\n    alt: \"A Codi.vim fullscreen buffer\",\n    width: \"1672\",\n    height: \"972\",\n    className: \"wide\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"Recently I discovered \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/metakirby5/codi.vim\",\n    \"title\": \"Visit metakirby5/codi.vim on GitHub\"\n  }, \"codi.vim\"), \" on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://vimawesome.com/?q=cat%3Aother\",\n    \"title\": \"Visit vimawesome.com 'Other' category plugin\"\n  }, \"vimawesome.com\"), \".\\nIt sells itself as an \\\"interactive scratchpad for hackers\\\".\\nAfter playing around with it for 5 minutes I was completely sold.\"), mdx(\"p\", null, \"I pair program on a weekly basis using various different languages.\\nI used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.\\nMaking a typo in the middle of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"do ... end\"), \" block in Ruby is quite costly:\"), mdx(Media, {\n    src: \"/media/posts/pry-multiline-typo\",\n    alt: \"Multiline expression typo in Pry\",\n    width: \"1033\",\n    height: \"250\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"Another thing to note here is that code and results are printed sequentially.\\nThis means that any code you write goes off-screen at least twice as fast because the result is printed below it.\"), mdx(\"p\", null, \"In case of errors and stack traces it can become a lot worse as well.\\nCodi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:\"), mdx(Media, {\n    src: \"/media/posts/ruby-demo\",\n    alt: \"Demo of Ruby in Codi.vim\",\n    width: \"1033\",\n    height: \"141\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"This feature, and the fact that I can toggle this buffer for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"multiple programming languages\"), \" using a single mapping blew my mind but as with anything,\\nit requires some more battle testing to see if it works in common scenario's.\"), mdx(\"h2\", null, \"Battle testing\"), mdx(\"p\", null, \"This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:\"), mdx(Media, {\n    src: \"/media/posts/split-behavior\",\n    alt: \"Default split behavior\",\n    width: \"1033\",\n    height: \"496\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"At this point I started experimenting with a small \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e\",\n    \"title\": \"Visit codi.vim snippet github gist\"\n  }, \"vimscript snippet\"), \" in my .vimrc.\\nExcluding comments and blanks it is 10 LoC.\\nIt wraps the default \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Codi\"), \" command in a function which creates an empty buffer in a new tab with the right filetype set before finally running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Codi\"), \" itself.\\nThis creates the fullscreen split that I wanted:\"), mdx(Media, {\n    src: \"/media/posts/wrapped-split-behavior\",\n    alt: \"Enhanced split behavior\",\n    width: \"1033\",\n    height: \"496\",\n    mdxType: \"Media\"\n  }), mdx(\"h2\", null, \"Problem solved, or maybe not?\"), mdx(\"p\", null, \"All good so far, but upon closing the buffer, the contents of the buffer are deleted.\\nWhile automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.\"), mdx(\"p\", null, \"This required a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62\",\n    \"title\": \"Visit second codi.vim snippet github gist\"\n  }, \"second iteration\"), \" of the original vimscript snippet.\\nThis time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.\\nAfter hiding the buffer, its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tabpagenr()\"), \" is stored in a dictionary keyed by the filetype of the buffer.\"), mdx(\"p\", null, \"Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):\"), mdx(Media, {\n    src: \"/media/posts/wrapped-split-behavior-2\",\n    alt: \"Enhanced split behavior version 2\",\n    width: \"1033\",\n    height: \"496\",\n    mdxType: \"Media\"\n  }), mdx(\"p\", null, \"And there we go! Aside from the fact that the buffer now remains, the name is also \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"scratch::ruby\"), \".\\nThis is a bit more descriptive than having just \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[Scratch]\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \":ls\"), \" output when multiple codi buffers of a different filetype are active.\"), mdx(\"h2\", null, \"Let's wrap it in an issue\"), mdx(\"p\", null, \"It was a fun experience tweaking this plugin to my liking.\\nI thought this feature would be so awesome that I even proposed it in an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/metakirby5/codi.vim/issues/94\",\n    \"title\": \"View metakirby5/codi.vim issue #94\"\n  }, \"issue\"), \".\\nUnfortunately it didn't make it since it was too workflow specific.\"), mdx(\"p\", null, \"As you may have been able to see in the issue though, the code in that snippet is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"slighty\"), \" different from the example gist linked in this post.\\nThe main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-viml\"\n  }, \"\\\" since it is fullscreen, I'd like a 50/50 split\\nlet g:codi#width = winwidth(winnr()) / 2\\n\")), mdx(\"p\", null, \"The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.\\nSo I went ahead and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/metakirby5/codi.vim/pull/95\",\n    \"title\": \"View metakirby5/codi.vim pull request #95\"\n  }, \"wrote a PR\"), \" for that instead, this is why you see\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let g:codi#width = 50.0\"), \" in the gists :)\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"All in all it was a great experience discovering this plugin.\\nIt is like one of those rare cases with a song where after a few seconds \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"you just know\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\\"this song is awesome\\\"\"), \".\\nI believe I'll be using it for a long time to come for quickly testing and showing some code.\"), mdx(\"p\", null, \"This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.\\nSomething which I wanted to do for a long time but couldn't really find the right project to contribute to.\\nI want to thank \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/@metakirby5\",\n    \"title\": \"View @metakirby5 on Medium\"\n  }, \"Ethan Chan\"), \" for his awesome plugin and for being a kind and friendly maintainer!\"), mdx(\"p\", null, \"That's it! If you want a fullscreen workflow with codi.vim, you have it.\\nIf you want to persist the code in the buffer, you have it.\\nIf you have a great idea, comment on this post!\"), mdx(\"p\", null, \"Until next time.\"), mdx(\"p\", null, \"\\uD83D\\uDC4B\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<figure class=\"wide media_figure__1BF98\"><div style=\"padding-bottom: 58.133971291866025%;\" class=\"media_relative__3Dzxp\"><img loading=\"lazy\" src=\"/media/posts/codi-banner.png\" alt=\"A Codi.vim fullscreen buffer\" class=\"media_media__1ZpPG\" /></div><figcaption class=\"media_alt__xSx7S\">A Codi.vim fullscreen buffer</figcaption></figure><p>Recently I discovered <a href=\"https://github.com/metakirby5/codi.vim\" title=\"Visit metakirby5/codi.vim on GitHub\">codi.vim</a> on <a href=\"https://vimawesome.com/?q=cat%3Aother\" title=\"Visit vimawesome.com 'Other' category plugin\">vimawesome.com</a>.\nIt sells itself as an &quot;interactive scratchpad for hackers&quot;.\nAfter playing around with it for 5 minutes I was completely sold.</p><p>I pair program on a weekly basis using various different languages.\nI used to turn to a REPL for help but this quickly becomes annoying when trying to write multi-line expressions.\nMaking a typo in the middle of a <code>do ... end</code> block in Ruby is quite costly:</p><figure class=\"media_figure__1BF98\"><div style=\"padding-bottom: 24.20135527589545%;\" class=\"media_relative__3Dzxp\"><video autoPlay loop muted playsInline class=\"media_media__1ZpPG\"><source src=\"/media/posts/pry-multiline-typo.webm\" type=\"video/webm\" /><source src=\"/media/posts/pry-multiline-typo.mp4\" type=\"video/mp4\" /></video></div><figcaption class=\"media_alt__xSx7S\">Multiline expression typo in Pry</figcaption></figure><p>Another thing to note here is that code and results are printed sequentially.\nThis means that any code you write goes off-screen at least twice as fast because the result is printed below it.</p><p>In case of errors and stack traces it can become a lot worse as well.\nCodi solves all of this by allowing you to type in one pane and it prints the results in a separate pane side-by-side:</p><figure class=\"media_figure__1BF98\"><div style=\"padding-bottom: 13.649564375605033%;\" class=\"media_relative__3Dzxp\"><video autoPlay loop muted playsInline class=\"media_media__1ZpPG\"><source src=\"/media/posts/ruby-demo.webm\" type=\"video/webm\" /><source src=\"/media/posts/ruby-demo.mp4\" type=\"video/mp4\" /></video></div><figcaption class=\"media_alt__xSx7S\">Demo of Ruby in Codi.vim</figcaption></figure><p>This feature, and the fact that I can toggle this buffer for <em>multiple programming languages</em> using a single mapping blew my mind but as with anything,\nit requires some more battle testing to see if it works in common scenario's.</p><h2 class=\"heading_container__2UElk\"><a id=\"battle-testing\" class=\"heading_anchor__PWj4r\"></a><a href=\"#battle-testing\" class=\"heading_link__1aoFY\">Battle testing</a></h2><p>This is where I found out that when used with a split, it will not be fullscreen but rather split the current buffer:</p><figure class=\"media_figure__1BF98\"><div style=\"padding-bottom: 48.01548886737657%;\" class=\"media_relative__3Dzxp\"><video autoPlay loop muted playsInline class=\"media_media__1ZpPG\"><source src=\"/media/posts/split-behavior.webm\" type=\"video/webm\" /><source src=\"/media/posts/split-behavior.mp4\" type=\"video/mp4\" /></video></div><figcaption class=\"media_alt__xSx7S\">Default split behavior</figcaption></figure><p>At this point I started experimenting with a small <a href=\"https://gist.github.com/SidOfc/5218a7a9f12ed2105a9b052ca8e6707e\" title=\"Visit codi.vim snippet github gist\">vimscript snippet</a> in my .vimrc.\nExcluding comments and blanks it is 10 LoC.\nIt wraps the default <code>Codi</code> command in a function which creates an empty buffer in a new tab with the right filetype set before finally running <code>Codi</code> itself.\nThis creates the fullscreen split that I wanted:</p><figure class=\"media_figure__1BF98\"><div style=\"padding-bottom: 48.01548886737657%;\" class=\"media_relative__3Dzxp\"><video autoPlay loop muted playsInline class=\"media_media__1ZpPG\"><source src=\"/media/posts/wrapped-split-behavior.webm\" type=\"video/webm\" /><source src=\"/media/posts/wrapped-split-behavior.mp4\" type=\"video/mp4\" /></video></div><figcaption class=\"media_alt__xSx7S\">Enhanced split behavior</figcaption></figure><h2 class=\"heading_container__2UElk\"><a id=\"problem-solved-or-maybe-not\" class=\"heading_anchor__PWj4r\"></a><a href=\"#problem-solved-or-maybe-not\" class=\"heading_link__1aoFY\">Problem solved, or maybe not?</a></h2><p>All good so far, but upon closing the buffer, the contents of the buffer are deleted.\nWhile automatically clearing the scratchpad is nice, sometimes I want to go back and forth between the code and the scratchpad to add additional code or compare the existing code with the scratchpad code.</p><p>This required a <a href=\"https://gist.github.com/SidOfc/3f94244a8b08406710b6669052f66d62\" title=\"Visit second codi.vim snippet github gist\">second iteration</a> of the original vimscript snippet.\nThis time I did not want to delete the buffer but hide it instead, keeping the code that was already written in it.\nAfter hiding the buffer, its <code>tabpagenr()</code> is stored in a dictionary keyed by the filetype of the buffer.</p><p>Then, when toggling codi for a filetype that is stored, switch to that tab instead of opening a new one (there is even a check if that tab actually exists):</p><figure class=\"media_figure__1BF98\"><div style=\"padding-bottom: 48.01548886737657%;\" class=\"media_relative__3Dzxp\"><video autoPlay loop muted playsInline class=\"media_media__1ZpPG\"><source src=\"/media/posts/wrapped-split-behavior-2.webm\" type=\"video/webm\" /><source src=\"/media/posts/wrapped-split-behavior-2.mp4\" type=\"video/mp4\" /></video></div><figcaption class=\"media_alt__xSx7S\">Enhanced split behavior version 2</figcaption></figure><p>And there we go! Aside from the fact that the buffer now remains, the name is also <code>scratch::ruby</code>.\nThis is a bit more descriptive than having just <code>[Scratch]</code> in <code>:ls</code> output when multiple codi buffers of a different filetype are active.</p><h2 class=\"heading_container__2UElk\"><a id=\"let-s-wrap-it-in-an-issue\" class=\"heading_anchor__PWj4r\"></a><a href=\"#let-s-wrap-it-in-an-issue\" class=\"heading_link__1aoFY\">Let's wrap it in an issue</a></h2><p>It was a fun experience tweaking this plugin to my liking.\nI thought this feature would be so awesome that I even proposed it in an <a href=\"https://github.com/metakirby5/codi.vim/issues/94\" title=\"View metakirby5/codi.vim issue #94\">issue</a>.\nUnfortunately it didn't make it since it was too workflow specific.</p><p>As you may have been able to see in the issue though, the code in that snippet is <em>slighty</em> different from the example gist linked in this post.\nThe main difference is this line which resizes codi to 50% of the buffer width whenever a new instance is spawned:</p><pre style=\"background-color: #2a2734; color: #9a86fd;\" class=\"prism-code language-viml\"><div style=\"color: #9a86fd;\" class=\"token-line\"><span style=\"color: #9390a1;\" class=\"token comment\">&quot; since it is fullscreen, I'd like a 50/50 split</span><span class=\"token plain\"></span></div><div style=\"color: #9a86fd;\" class=\"token-line\"><span class=\"token plain\"></span><span style=\"color: #ffcc99;\" class=\"token keyword\">let</span><span class=\"token plain\"> g</span><span style=\"color: #6c6783;\" class=\"token punctuation\">:</span><span class=\"token plain\">codi</span><span style=\"color: #6c6783;\" class=\"token punctuation\">#</span><span class=\"token plain\">width </span><span style=\"color: #e09142;\" class=\"token operator\">=</span><span class=\"token plain\"> </span><span style=\"color: #fa60c3;\" class=\"token function\">winwidth</span><span style=\"color: #6c6783;\" class=\"token punctuation\">(</span><span style=\"color: #fa60c3;\" class=\"token function\">winnr</span><span style=\"color: #6c6783;\" class=\"token punctuation\">(</span><span style=\"color: #6c6783;\" class=\"token punctuation\">)</span><span style=\"color: #6c6783;\" class=\"token punctuation\">)</span><span class=\"token plain\"> </span><span style=\"color: #e09142;\" class=\"token operator\">/</span><span class=\"token plain\"> </span><span style=\"color: #e09142;\" class=\"token number\">2</span></div></pre><p>The author thought it would be a nice addition to have percentage width support and for the snippets to live elsewhere for others to use in their .vimrc.\nSo I went ahead and <a href=\"https://github.com/metakirby5/codi.vim/pull/95\" title=\"View metakirby5/codi.vim pull request #95\">wrote a PR</a> for that instead, this is why you see\n<code>let g:codi#width = 50.0</code> in the gists :)</p><h2 class=\"heading_container__2UElk\"><a id=\"conclusion\" class=\"heading_anchor__PWj4r\"></a><a href=\"#conclusion\" class=\"heading_link__1aoFY\">Conclusion</a></h2><p>All in all it was a great experience discovering this plugin.\nIt is like one of those rare cases with a song where after a few seconds <strong>you just know</strong> <em>&quot;this song is awesome&quot;</em>.\nI believe I'll be using it for a long time to come for quickly testing and showing some code.</p><p>This also gave me the chance to write my first non-organization bound PR for a project which I like and now also use.\nSomething which I wanted to do for a long time but couldn't really find the right project to contribute to.\nI want to thank <a href=\"https://medium.com/@metakirby5\" title=\"View @metakirby5 on Medium\">Ethan Chan</a> for his awesome plugin and for being a kind and friendly maintainer!</p><p>That's it! If you want a fullscreen workflow with codi.vim, you have it.\nIf you want to persist the code in the buffer, you have it.\nIf you have a great idea, comment on this post!</p><p>Until next time.</p><p>👋</p>","scope":{"title":"Codi.vim + fullscreen buffer","description":"Learn how to set up Codi.vim to create a fullscreen scratch buffer that also works with Vim splits. We will take a look at wrapping the <code>Codi</code> command and improving the buffer name(s) as seen in <code>:ls</code>.","published":"2018-08-27T07:55:24Z"}},"slug":"codi-vim-fullscreen-buffer"},"__N_SSG":true}